{"ast":null,"code":"import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { multicall3Abi } from '../../constants/abis.js';\nimport { aggregate3Signature } from '../../constants/contract.js';\nimport { BaseError } from '../../errors/base.js';\nimport { ChainDoesNotSupportContract, ClientChainNotConfiguredError } from '../../errors/chain.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getChainContractAddress } from '../../utils/chain.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getCallError } from '../../utils/errors/getCallError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call.html\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call(client, args) {\n  var _client$batch;\n  const {\n    account: account_ = client.account,\n    batch = Boolean((_client$batch = client.batch) === null || _client$batch === void 0 ? void 0 : _client$batch.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args;\n  const account = account_ ? parseAccount(account_) : undefined;\n  try {\n    var _client$chain;\n    assertRequest(args);\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const format = ((_client$chain = client.chain) === null || _client$chain === void 0 || (_client$chain = _client$chain.formatters) === null || _client$chain === void 0 || (_client$chain = _client$chain.transactionRequest) === null || _client$chain === void 0 ? void 0 : _client$chain.format) || formatTransactionRequest;\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, {\n        format\n      }),\n      from: account === null || account === void 0 ? void 0 : account.address,\n      accessList,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value\n    });\n    if (batch && shouldPerformMulticall({\n      request\n    })) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag\n        });\n      } catch (err) {\n        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract)) throw err;\n      }\n    }\n    const response = await client.request({\n      method: 'eth_call',\n      params: block ? [request, block] : [request]\n    });\n    if (response === '0x') return {\n      data: undefined\n    };\n    return {\n      data: response\n    };\n  } catch (err) {\n    const data = getRevertErrorData(err);\n    const {\n      offchainLookup,\n      offchainLookupSignature\n    } = await import('../../utils/ccip.js');\n    if ((data === null || data === void 0 ? void 0 : data.slice(0, 10)) === offchainLookupSignature && to) {\n      return {\n        data: await offchainLookup(client, {\n          data,\n          to\n        })\n      };\n    }\n    throw getCallError(err, {\n      ...args,\n      account,\n      chain: client.chain\n    });\n  }\n}\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall(_ref) {\n  let {\n    request\n  } = _ref;\n  const {\n    data,\n    to,\n    ...request_\n  } = request;\n  if (!data) return false;\n  if (data.startsWith(aggregate3Signature)) return false;\n  if (!to) return false;\n  if (Object.values(request_).filter(x => typeof x !== 'undefined').length > 0) return false;\n  return true;\n}\nasync function scheduleMulticall(client, args) {\n  var _client$batch2;\n  const {\n    batchSize = 1024,\n    wait = 0\n  } = typeof ((_client$batch2 = client.batch) === null || _client$batch2 === void 0 ? void 0 : _client$batch2.multicall) === 'object' ? client.batch.multicall : {};\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to\n  } = args;\n  let multicallAddress = multicallAddress_;\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError();\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3'\n    });\n  }\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  const block = blockNumberHex || blockTag;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, _ref2) => {\n        let {\n          data\n        } = _ref2;\n        return size + (data.length - 2);\n      }, 0);\n      return size > batchSize * 2;\n    },\n    fn: async requests => {\n      const calls = requests.map(request => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to\n      }));\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3'\n      });\n      const data = await client.request({\n        method: 'eth_call',\n        params: [{\n          data: calldata,\n          to: multicallAddress\n        }, block]\n      });\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x'\n      });\n    }\n  });\n  const [{\n    returnData,\n    success\n  }] = await schedule({\n    data,\n    to\n  });\n  if (!success) throw new RawContractError({\n    data: returnData\n  });\n  if (returnData === '0x') return {\n    data: undefined\n  };\n  return {\n    data: returnData\n  };\n}\nexport function getRevertErrorData(err) {\n  if (!(err instanceof BaseError)) return undefined;\n  const error = err.walk();\n  return typeof error.data === 'object' ? error.data.data : error.data;\n}","map":{"version":3,"names":["parseAccount","multicall3Abi","aggregate3Signature","BaseError","ChainDoesNotSupportContract","ClientChainNotConfiguredError","RawContractError","decodeFunctionResult","encodeFunctionData","getChainContractAddress","numberToHex","getCallError","extract","formatTransactionRequest","createBatchScheduler","assertRequest","call","client","args","_client$batch","account","account_","batch","Boolean","multicall","blockNumber","blockTag","accessList","data","gas","gasPrice","maxFeePerGas","maxPriorityFeePerGas","nonce","to","value","rest","undefined","_client$chain","blockNumberHex","block","format","chain","formatters","transactionRequest","request","from","address","shouldPerformMulticall","scheduleMulticall","err","response","method","params","getRevertErrorData","offchainLookup","offchainLookupSignature","slice","_ref","request_","startsWith","Object","values","filter","x","length","_client$batch2","batchSize","wait","multicallAddress","multicallAddress_","contract","schedule","id","uid","shouldSplitBatch","size","reduce","_ref2","fn","requests","calls","map","allowFailure","callData","target","calldata","abi","functionName","returnData","success","error","walk"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/actions/public/call.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { aggregate3Signature } from '../../constants/contract.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ChainDoesNotSupportContract,\n  ClientChainNotConfiguredError,\n} from '../../errors/chain.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getCallError } from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\nimport type { AssertRequestParameters } from '../../utils/transaction/assertRequest.js'\n\nexport type FormattedCall<\n  TChain extends Chain | undefined = Chain | undefined,\n> = FormattedTransactionRequest<TChain>\n\nexport type CallParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedCall<TChain>, 'from'> & {\n  account?: Account | Address\n  batch?: boolean\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint\n        blockTag?: never\n      }\n    | {\n        blockNumber?: never\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag\n      }\n  )\n\nexport type CallReturnType = { data: Hex | undefined }\n\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call.html\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  args: CallParameters<TChain>,\n): Promise<CallReturnType> {\n  const {\n    account: account_ = client.account,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  try {\n    assertRequest(args as AssertRequestParameters)\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const format =\n      client.chain?.formatters?.transactionRequest?.format ||\n      formatTransactionRequest\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format }),\n      from: account?.address,\n      accessList,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    } as TransactionRequest) as TransactionRequest\n\n    if (batch && shouldPerformMulticall({ request })) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag,\n        } as unknown as ScheduleMulticallParameters<TChain>)\n      } catch (err) {\n        if (\n          !(err instanceof ClientChainNotConfiguredError) &&\n          !(err instanceof ChainDoesNotSupportContract)\n        )\n          throw err\n      }\n    }\n\n    const response = await client.request({\n      method: 'eth_call',\n      params: block\n        ? [request as Partial<RpcTransactionRequest>, block]\n        : [request as Partial<RpcTransactionRequest>],\n    })\n    if (response === '0x') return { data: undefined }\n    return { data: response }\n  } catch (err) {\n    const data = getRevertErrorData(err)\n    const { offchainLookup, offchainLookupSignature } = await import(\n      '../../utils/ccip.js'\n    )\n    if (data?.slice(0, 10) === offchainLookupSignature && to) {\n      return { data: await offchainLookup(client, { data, to }) }\n    }\n    throw getCallError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({ request }: { request: TransactionRequest }) {\n  const { data, to, ...request_ } = request\n  if (!data) return false\n  if (data.startsWith(aggregate3Signature)) return false\n  if (!to) return false\n  if (\n    Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0\n  )\n    return false\n  return true\n}\n\ntype ScheduleMulticallParameters<TChain extends Chain | undefined> = Pick<\n  CallParameters<TChain>,\n  'blockNumber' | 'blockTag'\n> & {\n  data: Hex\n  multicallAddress?: Address\n  to: Address\n}\n\nasync function scheduleMulticall<TChain extends Chain | undefined,>(\n  client: Client<Transport>,\n  args: ScheduleMulticallParameters<TChain>,\n) {\n  const { batchSize = 1024, wait = 0 } =\n    typeof client.batch?.multicall === 'object' ? client.batch.multicall : {}\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to,\n  } = args\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError()\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n  const block = blockNumberHex || blockTag\n\n  const { schedule } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, { data }) => size + (data.length - 2), 0)\n      return size > batchSize * 2\n    },\n    fn: async (\n      requests: {\n        data: Hex\n        to: Address\n      }[],\n    ) => {\n      const calls = requests.map((request) => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to,\n      }))\n\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n      })\n\n      const data = await client.request({\n        method: 'eth_call',\n        params: [\n          {\n            data: calldata,\n            to: multicallAddress,\n          },\n          block,\n        ],\n      })\n\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x',\n      })\n    },\n  })\n\n  const [{ returnData, success }] = await schedule({ data, to })\n\n  if (!success) throw new RawContractError({ data: returnData })\n  if (returnData === '0x') return { data: undefined }\n  return { data: returnData }\n}\n\nexport function getRevertErrorData(err: unknown) {\n  if (!(err instanceof BaseError)) return undefined\n  const error = err.walk() as RawContractError\n  return typeof error.data === 'object' ? error.data.data : error.data\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}