{"ast":null,"code":"import { DataLengthTooLongError, DataLengthTooShortError, InvalidHexValueError, OffsetOutOfBoundsError } from '../../errors/encoding.js';\nimport { bytesToNumber } from './fromBytes.js';\nimport { hexToBytes } from './toBytes.js';\nimport { bytesToHex } from './toHex.js';\nexport function fromRlp(value, to) {\n  const bytes = parse(value);\n  const [data, consumed] = rlpToBytes(bytes);\n  if (consumed < bytes.length) throw new DataLengthTooLongError({\n    consumed,\n    length: bytes.length\n  });\n  return format(data, to);\n}\nfunction parse(value) {\n  if (typeof value === 'string') {\n    if (value.length > 3 && value.length % 2 !== 0) throw new InvalidHexValueError(value);\n    return hexToBytes(value);\n  }\n  return value;\n}\nfunction format(bytes, to) {\n  if (Array.isArray(bytes)) return bytes.map(b => format(b, to));\n  return to === 'hex' ? bytesToHex(bytes) : bytes;\n}\nfunction rlpToBytes(bytes) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (bytes.length === 0) return [new Uint8Array([]), 0];\n  const prefix = bytes[offset];\n  if (prefix <= 0x7f) return [new Uint8Array([bytes[offset]]), 1];\n  if (prefix <= 0xb7) {\n    const length = prefix - 0x80;\n    const offset_ = offset + 1;\n    if (offset_ + length > bytes.length) throw new DataLengthTooShortError({\n      length: offset_ + length,\n      dataLength: bytes.length\n    });\n    return [bytes.slice(offset_, offset_ + length), 1 + length];\n  }\n  if (prefix <= 0xbf) {\n    const lengthOfLength = prefix - 0xb7;\n    const offset_ = offset + 1;\n    const length = bytesToNumber(bytes.slice(offset_, offset_ + lengthOfLength));\n    if (offset_ + lengthOfLength + length > bytes.length) throw new DataLengthTooShortError({\n      length: lengthOfLength + length,\n      dataLength: bytes.length - lengthOfLength\n    });\n    return [bytes.slice(offset_ + lengthOfLength, offset_ + lengthOfLength + length), 1 + lengthOfLength + length];\n  }\n  let lengthOfLength = 0;\n  let length = prefix - 0xc0;\n  if (prefix > 0xf7) {\n    lengthOfLength = prefix - 0xf7;\n    length = bytesToNumber(bytes.slice(offset + 1, offset + 1 + lengthOfLength));\n  }\n  let nextOffset = offset + 1 + lengthOfLength;\n  if (nextOffset > bytes.length) throw new DataLengthTooShortError({\n    length: nextOffset,\n    dataLength: bytes.length\n  });\n  const consumed = 1 + lengthOfLength + length;\n  const result = [];\n  while (nextOffset < offset + consumed) {\n    const decoded = rlpToBytes(bytes, nextOffset);\n    result.push(decoded[0]);\n    nextOffset += decoded[1];\n    if (nextOffset > offset + consumed) throw new OffsetOutOfBoundsError({\n      nextOffset: nextOffset,\n      offset: offset + consumed\n    });\n  }\n  return [result, consumed];\n}","map":{"version":3,"names":["DataLengthTooLongError","DataLengthTooShortError","InvalidHexValueError","OffsetOutOfBoundsError","bytesToNumber","hexToBytes","bytesToHex","fromRlp","value","to","bytes","parse","data","consumed","rlpToBytes","length","format","Array","isArray","map","b","offset","arguments","undefined","Uint8Array","prefix","offset_","dataLength","slice","lengthOfLength","nextOffset","result","decoded","push"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/encoding/fromRlp.ts"],"sourcesContent":["import {\n  DataLengthTooLongError,\n  DataLengthTooShortError,\n  InvalidHexValueError,\n  OffsetOutOfBoundsError,\n} from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { bytesToNumber } from './fromBytes.js'\nimport { hexToBytes } from './toBytes.js'\nimport { bytesToHex } from './toHex.js'\nimport type { RecursiveArray } from './toRlp.js'\n\ntype FromRlpReturnType<TTo> = TTo extends 'bytes'\n  ? ByteArray\n  : TTo extends 'hex'\n  ? Hex\n  : never\n\nexport function fromRlp<TTo extends 'bytes' | 'hex'>(\n  value: ByteArray | Hex,\n  to: TTo,\n): RecursiveArray<FromRlpReturnType<TTo>> {\n  const bytes = parse(value)\n  const [data, consumed] = rlpToBytes(bytes)\n  if (consumed < bytes.length)\n    throw new DataLengthTooLongError({\n      consumed,\n      length: bytes.length,\n    })\n  return format(data, to)\n}\n\nfunction parse(value: ByteArray | Hex) {\n  if (typeof value === 'string') {\n    if (value.length > 3 && value.length % 2 !== 0)\n      throw new InvalidHexValueError(value)\n    return hexToBytes(value)\n  }\n  return value\n}\n\nfunction format<TTo extends 'bytes' | 'hex'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: TTo,\n): RecursiveArray<FromRlpReturnType<TTo>> {\n  if (Array.isArray(bytes)) return bytes.map((b) => format(b, to))\n  return (to === 'hex' ? bytesToHex(bytes) : bytes) as FromRlpReturnType<TTo>\n}\n\nfunction rlpToBytes(\n  bytes: ByteArray,\n  offset = 0,\n): [result: RecursiveArray<ByteArray>, consumed: number] {\n  if (bytes.length === 0) return [new Uint8Array([]), 0]\n\n  const prefix = bytes[offset]\n\n  if (prefix <= 0x7f) return [new Uint8Array([bytes[offset]]), 1]\n\n  if (prefix <= 0xb7) {\n    const length = prefix - 0x80\n    const offset_ = offset + 1\n\n    if (offset_ + length > bytes.length)\n      throw new DataLengthTooShortError({\n        length: offset_ + length,\n        dataLength: bytes.length,\n      })\n\n    return [bytes.slice(offset_, offset_ + length), 1 + length]\n  }\n\n  if (prefix <= 0xbf) {\n    const lengthOfLength = prefix - 0xb7\n    const offset_ = offset + 1\n    const length = bytesToNumber(bytes.slice(offset_, offset_ + lengthOfLength))\n\n    if (offset_ + lengthOfLength + length > bytes.length)\n      throw new DataLengthTooShortError({\n        length: lengthOfLength + length,\n        dataLength: bytes.length - lengthOfLength,\n      })\n\n    return [\n      bytes.slice(offset_ + lengthOfLength, offset_ + lengthOfLength + length),\n      1 + lengthOfLength + length,\n    ]\n  }\n\n  let lengthOfLength = 0\n  let length = prefix - 0xc0\n  if (prefix > 0xf7) {\n    lengthOfLength = prefix - 0xf7\n    length = bytesToNumber(bytes.slice(offset + 1, offset + 1 + lengthOfLength))\n  }\n\n  let nextOffset = offset + 1 + lengthOfLength\n  if (nextOffset > bytes.length)\n    throw new DataLengthTooShortError({\n      length: nextOffset,\n      dataLength: bytes.length,\n    })\n\n  const consumed = 1 + lengthOfLength + length\n  const result = []\n  while (nextOffset < offset + consumed) {\n    const decoded = rlpToBytes(bytes, nextOffset)\n    result.push(decoded[0])\n    nextOffset += decoded[1]\n    if (nextOffset > offset + consumed)\n      throw new OffsetOutOfBoundsError({\n        nextOffset: nextOffset,\n        offset: offset + consumed,\n      })\n  }\n\n  return [result, consumed]\n}\n"],"mappings":"AAAA,SACEA,sBAAsB,EACtBC,uBAAuB,EACvBC,oBAAoB,EACpBC,sBAAsB,QACjB,0BAA0B;AAGjC,SAASC,aAAa,QAAQ,gBAAgB;AAC9C,SAASC,UAAU,QAAQ,cAAc;AACzC,SAASC,UAAU,QAAQ,YAAY;AASvC,OAAM,SAAUC,OAAOA,CACrBC,KAAsB,EACtBC,EAAO;EAEP,MAAMC,KAAK,GAAGC,KAAK,CAACH,KAAK,CAAC;EAC1B,MAAM,CAACI,IAAI,EAAEC,QAAQ,CAAC,GAAGC,UAAU,CAACJ,KAAK,CAAC;EAC1C,IAAIG,QAAQ,GAAGH,KAAK,CAACK,MAAM,EACzB,MAAM,IAAIf,sBAAsB,CAAC;IAC/Ba,QAAQ;IACRE,MAAM,EAAEL,KAAK,CAACK;GACf,CAAC;EACJ,OAAOC,MAAM,CAACJ,IAAI,EAAEH,EAAE,CAAC;AACzB;AAEA,SAASE,KAAKA,CAACH,KAAsB;EACnC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIA,KAAK,CAACO,MAAM,GAAG,CAAC,IAAIP,KAAK,CAACO,MAAM,GAAG,CAAC,KAAK,CAAC,EAC5C,MAAM,IAAIb,oBAAoB,CAACM,KAAK,CAAC;IACvC,OAAOH,UAAU,CAACG,KAAK,CAAC;;EAE1B,OAAOA,KAAK;AACd;AAEA,SAASQ,MAAMA,CACbN,KAAgC,EAChCD,EAAO;EAEP,IAAIQ,KAAK,CAACC,OAAO,CAACR,KAAK,CAAC,EAAE,OAAOA,KAAK,CAACS,GAAG,CAAEC,CAAC,IAAKJ,MAAM,CAACI,CAAC,EAAEX,EAAE,CAAC,CAAC;EAChE,OAAQA,EAAE,KAAK,KAAK,GAAGH,UAAU,CAACI,KAAK,CAAC,GAAGA,KAAK;AAClD;AAEA,SAASI,UAAUA,CACjBJ,KAAgB,EACN;EAAA,IAAVW,MAAM,GAAAC,SAAA,CAAAP,MAAA,QAAAO,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;EAEV,IAAIZ,KAAK,CAACK,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC,IAAIS,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAEtD,MAAMC,MAAM,GAAGf,KAAK,CAACW,MAAM,CAAC;EAE5B,IAAII,MAAM,IAAI,IAAI,EAAE,OAAO,CAAC,IAAID,UAAU,CAAC,CAACd,KAAK,CAACW,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAE/D,IAAII,MAAM,IAAI,IAAI,EAAE;IAClB,MAAMV,MAAM,GAAGU,MAAM,GAAG,IAAI;IAC5B,MAAMC,OAAO,GAAGL,MAAM,GAAG,CAAC;IAE1B,IAAIK,OAAO,GAAGX,MAAM,GAAGL,KAAK,CAACK,MAAM,EACjC,MAAM,IAAId,uBAAuB,CAAC;MAChCc,MAAM,EAAEW,OAAO,GAAGX,MAAM;MACxBY,UAAU,EAAEjB,KAAK,CAACK;KACnB,CAAC;IAEJ,OAAO,CAACL,KAAK,CAACkB,KAAK,CAACF,OAAO,EAAEA,OAAO,GAAGX,MAAM,CAAC,EAAE,CAAC,GAAGA,MAAM,CAAC;;EAG7D,IAAIU,MAAM,IAAI,IAAI,EAAE;IAClB,MAAMI,cAAc,GAAGJ,MAAM,GAAG,IAAI;IACpC,MAAMC,OAAO,GAAGL,MAAM,GAAG,CAAC;IAC1B,MAAMN,MAAM,GAAGX,aAAa,CAACM,KAAK,CAACkB,KAAK,CAACF,OAAO,EAAEA,OAAO,GAAGG,cAAc,CAAC,CAAC;IAE5E,IAAIH,OAAO,GAAGG,cAAc,GAAGd,MAAM,GAAGL,KAAK,CAACK,MAAM,EAClD,MAAM,IAAId,uBAAuB,CAAC;MAChCc,MAAM,EAAEc,cAAc,GAAGd,MAAM;MAC/BY,UAAU,EAAEjB,KAAK,CAACK,MAAM,GAAGc;KAC5B,CAAC;IAEJ,OAAO,CACLnB,KAAK,CAACkB,KAAK,CAACF,OAAO,GAAGG,cAAc,EAAEH,OAAO,GAAGG,cAAc,GAAGd,MAAM,CAAC,EACxE,CAAC,GAAGc,cAAc,GAAGd,MAAM,CAC5B;;EAGH,IAAIc,cAAc,GAAG,CAAC;EACtB,IAAId,MAAM,GAAGU,MAAM,GAAG,IAAI;EAC1B,IAAIA,MAAM,GAAG,IAAI,EAAE;IACjBI,cAAc,GAAGJ,MAAM,GAAG,IAAI;IAC9BV,MAAM,GAAGX,aAAa,CAACM,KAAK,CAACkB,KAAK,CAACP,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAG,CAAC,GAAGQ,cAAc,CAAC,CAAC;;EAG9E,IAAIC,UAAU,GAAGT,MAAM,GAAG,CAAC,GAAGQ,cAAc;EAC5C,IAAIC,UAAU,GAAGpB,KAAK,CAACK,MAAM,EAC3B,MAAM,IAAId,uBAAuB,CAAC;IAChCc,MAAM,EAAEe,UAAU;IAClBH,UAAU,EAAEjB,KAAK,CAACK;GACnB,CAAC;EAEJ,MAAMF,QAAQ,GAAG,CAAC,GAAGgB,cAAc,GAAGd,MAAM;EAC5C,MAAMgB,MAAM,GAAG,EAAE;EACjB,OAAOD,UAAU,GAAGT,MAAM,GAAGR,QAAQ,EAAE;IACrC,MAAMmB,OAAO,GAAGlB,UAAU,CAACJ,KAAK,EAAEoB,UAAU,CAAC;IAC7CC,MAAM,CAACE,IAAI,CAACD,OAAO,CAAC,CAAC,CAAC,CAAC;IACvBF,UAAU,IAAIE,OAAO,CAAC,CAAC,CAAC;IACxB,IAAIF,UAAU,GAAGT,MAAM,GAAGR,QAAQ,EAChC,MAAM,IAAIV,sBAAsB,CAAC;MAC/B2B,UAAU,EAAEA,UAAU;MACtBT,MAAM,EAAEA,MAAM,GAAGR;KAClB,CAAC;;EAGN,OAAO,CAACkB,MAAM,EAAElB,QAAQ,CAAC;AAC3B"},"metadata":{},"sourceType":"module","externalDependencies":[]}