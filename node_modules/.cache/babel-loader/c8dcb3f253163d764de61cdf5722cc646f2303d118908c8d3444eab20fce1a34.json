{"ast":null,"code":"import { SliceOffsetOutOfBoundsError } from '../../errors/data.js';\nimport { isHex } from './isHex.js';\nimport { size } from './size.js';\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice(value, start, end) {\n  let {\n    strict\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (isHex(value, {\n    strict: false\n  })) return sliceHex(value, start, end, {\n    strict\n  });\n  return sliceBytes(value, start, end, {\n    strict\n  });\n}\nfunction assertStartOffset(value, start) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1) throw new SliceOffsetOutOfBoundsError({\n    offset: start,\n    position: 'start',\n    size: size(value)\n  });\n}\nfunction assertEndOffset(value, start, end) {\n  if (typeof start === 'number' && typeof end === 'number' && size(value) !== end - start) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value)\n    });\n  }\n}\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(value_, start, end) {\n  let {\n    strict\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  assertStartOffset(value_, start);\n  const value = value_.slice(start, end);\n  if (strict) assertEndOffset(value, start, end);\n  return value;\n}\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(value_, start, end) {\n  let {\n    strict\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  assertStartOffset(value_, start);\n  const value = `0x${value_.replace('0x', '').slice((start !== null && start !== void 0 ? start : 0) * 2, (end !== null && end !== void 0 ? end : value_.length) * 2)}`;\n  if (strict) assertEndOffset(value, start, end);\n  return value;\n}","map":{"version":3,"names":["SliceOffsetOutOfBoundsError","isHex","size","slice","value","start","end","strict","arguments","length","undefined","sliceHex","sliceBytes","assertStartOffset","offset","position","assertEndOffset","value_","replace"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/data/slice.ts"],"sourcesContent":["import { SliceOffsetOutOfBoundsError } from '../../errors/data.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { isHex } from './isHex.js'\nimport { size } from './size.js'\n\nexport type SliceReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<TValue extends ByteArray | Hex>(\n  value: TValue,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): SliceReturnType<TValue> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<TValue>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<TValue>\n}\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nfunction assertEndOffset(value: Hex | ByteArray, start?: number, end?: number) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n"],"mappings":"AAAA,SAASA,2BAA2B,QAAQ,sBAAsB;AAGlE,SAASC,KAAK,QAAQ,YAAY;AAClC,SAASC,IAAI,QAAQ,WAAW;AAMhC;;;;;;;AAOA,OAAM,SAAUC,KAAKA,CACnBC,KAAa,EACbC,KAAc,EACdC,GAAY,EACyB;EAAA,IAArC;IAAEC;EAAM,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;EAErC,IAAIP,KAAK,CAACG,KAAK,EAAE;IAAEG,MAAM,EAAE;EAAK,CAAE,CAAC,EACjC,OAAOI,QAAQ,CAACP,KAAY,EAAEC,KAAK,EAAEC,GAAG,EAAE;IACxCC;GACD,CAA4B;EAC/B,OAAOK,UAAU,CAACR,KAAkB,EAAEC,KAAK,EAAEC,GAAG,EAAE;IAChDC;GACD,CAA4B;AAC/B;AAEA,SAASM,iBAAiBA,CAACT,KAAsB,EAAEC,KAAc;EAC/D,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,GAAGH,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC,EACnE,MAAM,IAAIJ,2BAA2B,CAAC;IACpCc,MAAM,EAAET,KAAK;IACbU,QAAQ,EAAE,OAAO;IACjBb,IAAI,EAAEA,IAAI,CAACE,KAAK;GACjB,CAAC;AACN;AAEA,SAASY,eAAeA,CAACZ,KAAsB,EAAEC,KAAc,EAAEC,GAAY;EAC3E,IACE,OAAOD,KAAK,KAAK,QAAQ,IACzB,OAAOC,GAAG,KAAK,QAAQ,IACvBJ,IAAI,CAACE,KAAK,CAAC,KAAKE,GAAG,GAAGD,KAAK,EAC3B;IACA,MAAM,IAAIL,2BAA2B,CAAC;MACpCc,MAAM,EAAER,GAAG;MACXS,QAAQ,EAAE,KAAK;MACfb,IAAI,EAAEA,IAAI,CAACE,KAAK;KACjB,CAAC;;AAEN;AAEA;;;;;;;AAOA,OAAM,SAAUQ,UAAUA,CACxBK,MAAiB,EACjBZ,KAAc,EACdC,GAAY,EACyB;EAAA,IAArC;IAAEC;EAAM,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;EAErCK,iBAAiB,CAACI,MAAM,EAAEZ,KAAK,CAAC;EAChC,MAAMD,KAAK,GAAGa,MAAM,CAACd,KAAK,CAACE,KAAK,EAAEC,GAAG,CAAC;EACtC,IAAIC,MAAM,EAAES,eAAe,CAACZ,KAAK,EAAEC,KAAK,EAAEC,GAAG,CAAC;EAC9C,OAAOF,KAAK;AACd;AAEA;;;;;;;AAOA,OAAM,SAAUO,QAAQA,CACtBM,MAAW,EACXZ,KAAc,EACdC,GAAY,EACyB;EAAA,IAArC;IAAEC;EAAM,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;EAErCK,iBAAiB,CAACI,MAAM,EAAEZ,KAAK,CAAC;EAChC,MAAMD,KAAK,GAAG,KAAKa,MAAM,CACtBC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CACjBf,KAAK,CAAC,CAACE,KAAK,aAALA,KAAK,cAALA,KAAK,GAAI,CAAC,IAAI,CAAC,EAAE,CAACC,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAIW,MAAM,CAACR,MAAM,IAAI,CAAC,CAAC,EAAW;EACjE,IAAIF,MAAM,EAAES,eAAe,CAACZ,KAAK,EAAEC,KAAK,EAAEC,GAAG,CAAC;EAC9C,OAAOF,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}