{"ast":null,"code":"import { call } from '../actions/public/call.js';\nimport '../errors/base.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [{\n    name: 'sender',\n    type: 'address'\n  }, {\n    name: 'urls',\n    type: 'string[]'\n  }, {\n    name: 'callData',\n    type: 'bytes'\n  }, {\n    name: 'callbackFunction',\n    type: 'bytes4'\n  }, {\n    name: 'extraData',\n    type: 'bytes'\n  }]\n};\nexport async function offchainLookup(client, _ref) {\n  let {\n    blockNumber,\n    blockTag,\n    data,\n    to\n  } = _ref;\n  const {\n    args\n  } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem]\n  });\n  const [sender, urls, callData, callbackSelector, extraData] = args;\n  try {\n    if (!isAddressEqual(to, sender)) throw new OffchainLookupSenderMismatchError({\n      sender,\n      to\n    });\n    const result = await ccipFetch({\n      data: callData,\n      sender,\n      urls\n    });\n    const {\n      data: data_\n    } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([callbackSelector, encodeAbiParameters([{\n        type: 'bytes'\n      }, {\n        type: 'bytes'\n      }], [result, extraData])]),\n      to\n    });\n    return data_;\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err,\n      data,\n      extraData,\n      sender,\n      urls\n    });\n  }\n}\nexport async function ccipFetch(_ref2) {\n  let {\n    data,\n    sender,\n    urls\n  } = _ref2;\n  let error = new Error('An unknown error occurred.');\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const method = url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST';\n    const body = method === 'POST' ? {\n      data,\n      sender\n    } : undefined;\n    try {\n      var _response$headers$get;\n      const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n        body: JSON.stringify(body),\n        method\n      });\n      let result;\n      if ((_response$headers$get = response.headers.get('Content-Type')) !== null && _response$headers$get !== void 0 && _response$headers$get.startsWith('application/json')) {\n        result = (await response.json()).data;\n      } else {\n        result = await response.text();\n      }\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url\n        });\n        continue;\n      }\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url\n        });\n        continue;\n      }\n      return result;\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: err.message,\n        url\n      });\n    }\n  }\n  throw error;\n}","map":{"version":3,"names":["call","OffchainLookupError","OffchainLookupResponseMalformedError","OffchainLookupSenderMismatchError","HttpRequestError","decodeErrorResult","encodeAbiParameters","isAddressEqual","concat","isHex","stringify","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","offchainLookup","client","_ref","blockNumber","blockTag","data","to","args","abi","sender","urls","callData","callbackSelector","extraData","result","ccipFetch","data_","err","cause","_ref2","error","Error","i","length","url","method","includes","body","undefined","_response$headers$get","response","fetch","replace","JSON","headers","get","startsWith","json","text","ok","details","statusText","status","message"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport { type BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  OffchainLookupResponseMalformedError,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { GetErrorArgs } from '../types/contract.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport async function offchainLookup<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  }) as unknown as GetErrorArgs<\n    [typeof offchainLookupAbiItem],\n    'OffchainLookup'\n  >\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipFetch({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport async function ccipFetch({\n  data,\n  sender,\n  urls,\n}: { data: Hex; sender: Address; urls: readonly string[] }) {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method =\n      url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}