{"ast":null,"code":"import { getJsonImage, getMetadataAvatarUri, getNftTokenUri, parseAvatarUri, parseNftUri, resolveAvatarUri } from './utils.js';\nexport async function parseAvatarRecord(client, _ref) {\n  let {\n    gatewayUrls,\n    record\n  } = _ref;\n  if (/eip155:/i.test(record)) return parseNftAvatarUri(client, {\n    gatewayUrls,\n    record\n  });\n  return parseAvatarUri({\n    uri: record,\n    gatewayUrls\n  });\n}\nasync function parseNftAvatarUri(client, _ref2) {\n  let {\n    gatewayUrls,\n    record\n  } = _ref2;\n  // parse NFT URI into properties\n  const nft = parseNftUri(record);\n  // fetch tokenURI from the NFT contract\n  const nftUri = await getNftTokenUri(client, {\n    nft\n  });\n  // resolve the URI from the fetched tokenURI\n  const {\n    uri: resolvedNftUri,\n    isOnChain,\n    isEncoded\n  } = resolveAvatarUri({\n    uri: nftUri,\n    gatewayUrls\n  });\n  // if the resolved URI is on chain, return the data\n  if (isOnChain && (resolvedNftUri.includes('data:application/json;base64,') || resolvedNftUri.startsWith('{'))) {\n    const encodedJson = isEncoded ?\n    // if it is encoded, decode it\n    atob(resolvedNftUri.replace('data:application/json;base64,', '')) :\n    // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)\n    resolvedNftUri;\n    const decoded = JSON.parse(encodedJson);\n    return parseAvatarUri({\n      uri: getJsonImage(decoded),\n      gatewayUrls\n    });\n  }\n  let uriTokenId = nft.tokenID;\n  if (nft.namespace === 'erc1155') uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');\n  return getMetadataAvatarUri({\n    gatewayUrls,\n    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)\n  });\n}","map":{"version":3,"names":["getJsonImage","getMetadataAvatarUri","getNftTokenUri","parseAvatarUri","parseNftUri","resolveAvatarUri","parseAvatarRecord","client","_ref","gatewayUrls","record","test","parseNftAvatarUri","uri","_ref2","nft","nftUri","resolvedNftUri","isOnChain","isEncoded","includes","startsWith","encodedJson","atob","replace","decoded","JSON","parse","uriTokenId","tokenID","namespace","padStart"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/utils/ens/avatar/parseAvatarRecord.ts"],"sourcesContent":["import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\nimport {\n  getJsonImage,\n  getMetadataAvatarUri,\n  getNftTokenUri,\n  parseAvatarUri,\n  parseNftUri,\n  resolveAvatarUri,\n} from './utils.js'\n\nexport async function parseAvatarRecord<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls\n    record: string\n  },\n): Promise<string> {\n  if (/eip155:/i.test(record))\n    return parseNftAvatarUri(client, { gatewayUrls, record })\n  return parseAvatarUri({ uri: record, gatewayUrls })\n}\n\nasync function parseNftAvatarUri<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls\n    record: string\n  },\n): Promise<string> {\n  // parse NFT URI into properties\n  const nft = parseNftUri(record)\n  // fetch tokenURI from the NFT contract\n  const nftUri = await getNftTokenUri(client, { nft })\n  // resolve the URI from the fetched tokenURI\n  const {\n    uri: resolvedNftUri,\n    isOnChain,\n    isEncoded,\n  } = resolveAvatarUri({ uri: nftUri, gatewayUrls })\n\n  // if the resolved URI is on chain, return the data\n  if (\n    isOnChain &&\n    (resolvedNftUri.includes('data:application/json;base64,') ||\n      resolvedNftUri.startsWith('{'))\n  ) {\n    const encodedJson = isEncoded\n      ? // if it is encoded, decode it\n        atob(resolvedNftUri.replace('data:application/json;base64,', ''))\n      : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)\n        resolvedNftUri\n\n    const decoded = JSON.parse(encodedJson)\n    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls })\n  }\n\n  let uriTokenId = nft.tokenID\n  if (nft.namespace === 'erc1155')\n    uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0')\n\n  return getMetadataAvatarUri({\n    gatewayUrls,\n    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),\n  })\n}\n"],"mappings":"AAKA,SACEA,YAAY,EACZC,oBAAoB,EACpBC,cAAc,EACdC,cAAc,EACdC,WAAW,EACXC,gBAAgB,QACX,YAAY;AAEnB,OAAO,eAAeC,iBAAiBA,CACrCC,MAAiC,EAAAC,IAAA,EAOhC;EAAA,IAND;IACEC,WAAW;IACXC;EAAM,CAIP,GAAAF,IAAA;EAED,IAAI,UAAU,CAACG,IAAI,CAACD,MAAM,CAAC,EACzB,OAAOE,iBAAiB,CAACL,MAAM,EAAE;IAAEE,WAAW;IAAEC;EAAM,CAAE,CAAC;EAC3D,OAAOP,cAAc,CAAC;IAAEU,GAAG,EAAEH,MAAM;IAAED;EAAW,CAAE,CAAC;AACrD;AAEA,eAAeG,iBAAiBA,CAC9BL,MAAiC,EAAAO,KAAA,EAOhC;EAAA,IAND;IACEL,WAAW;IACXC;EAAM,CAIP,GAAAI,KAAA;EAED;EACA,MAAMC,GAAG,GAAGX,WAAW,CAACM,MAAM,CAAC;EAC/B;EACA,MAAMM,MAAM,GAAG,MAAMd,cAAc,CAACK,MAAM,EAAE;IAAEQ;EAAG,CAAE,CAAC;EACpD;EACA,MAAM;IACJF,GAAG,EAAEI,cAAc;IACnBC,SAAS;IACTC;EAAS,CACV,GAAGd,gBAAgB,CAAC;IAAEQ,GAAG,EAAEG,MAAM;IAAEP;EAAW,CAAE,CAAC;EAElD;EACA,IACES,SAAS,KACRD,cAAc,CAACG,QAAQ,CAAC,+BAA+B,CAAC,IACvDH,cAAc,CAACI,UAAU,CAAC,GAAG,CAAC,CAAC,EACjC;IACA,MAAMC,WAAW,GAAGH,SAAS;IACzB;IACAI,IAAI,CAACN,cAAc,CAACO,OAAO,CAAC,+BAA+B,EAAE,EAAE,CAAC,CAAC;IACjE;IACAP,cAAc;IAElB,MAAMQ,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACL,WAAW,CAAC;IACvC,OAAOnB,cAAc,CAAC;MAAEU,GAAG,EAAEb,YAAY,CAACyB,OAAO,CAAC;MAAEhB;IAAW,CAAE,CAAC;;EAGpE,IAAImB,UAAU,GAAGb,GAAG,CAACc,OAAO;EAC5B,IAAId,GAAG,CAACe,SAAS,KAAK,SAAS,EAC7BF,UAAU,GAAGA,UAAU,CAACJ,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAACO,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;EAE7D,OAAO9B,oBAAoB,CAAC;IAC1BQ,WAAW;IACXI,GAAG,EAAEI,cAAc,CAACO,OAAO,CAAC,aAAa,EAAEI,UAAU;GACtD,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}