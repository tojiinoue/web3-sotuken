{"ast":null,"code":"import { AbiEncodingLengthMismatchError, BytesSizeMismatchError, UnsupportedPackedAbiType } from '../../errors/abi.js';\nimport { InvalidAddressError } from '../../errors/address.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concatHex } from '../data/concat.js';\nimport { pad } from '../data/pad.js';\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js';\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js';\nexport function encodePacked(types, values) {\n  if (types.length !== values.length) throw new AbiEncodingLengthMismatchError({\n    expectedLength: types.length,\n    givenLength: values.length\n  });\n  const data = [];\n  for (let i = 0; i < types.length; i++) {\n    const type = types[i];\n    const value = values[i];\n    data.push(encode(type, value));\n  }\n  return concatHex(data);\n}\nfunction encode(type, value) {\n  let isArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (type === 'address') {\n    const address = value;\n    if (!isAddress(address)) throw new InvalidAddressError({\n      address\n    });\n    return pad(address.toLowerCase(), {\n      size: isArray ? 32 : null\n    });\n  }\n  if (type === 'string') return stringToHex(value);\n  if (type === 'bytes') return value;\n  if (type === 'bool') return pad(boolToHex(value), {\n    size: isArray ? 32 : 1\n  });\n  const intMatch = type.match(integerRegex);\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch;\n    const size = parseInt(bits) / 8;\n    return numberToHex(value, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int'\n    });\n  }\n  const bytesMatch = type.match(bytesRegex);\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch;\n    if (parseInt(size) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n      expectedSize: parseInt(size),\n      givenSize: (value.length - 2) / 2\n    });\n    return pad(value, {\n      dir: 'right',\n      size: isArray ? 32 : null\n    });\n  }\n  const arrayMatch = type.match(arrayRegex);\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch;\n    const data = [];\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true));\n    }\n    if (data.length === 0) return '0x';\n    return concatHex(data);\n  }\n  throw new UnsupportedPackedAbiType(type);\n}","map":{"version":3,"names":["AbiEncodingLengthMismatchError","BytesSizeMismatchError","UnsupportedPackedAbiType","InvalidAddressError","isAddress","concatHex","pad","boolToHex","numberToHex","stringToHex","arrayRegex","bytesRegex","integerRegex","encodePacked","types","values","length","expectedLength","givenLength","data","i","type","value","push","encode","isArray","arguments","undefined","address","toLowerCase","size","intMatch","match","_type","baseType","bits","parseInt","signed","bytesMatch","expectedSize","givenSize","dir","arrayMatch","Array","childType"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/abi/encodePacked.ts"],"sourcesContent":["import type {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Address,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\n\nimport {\n  AbiEncodingLengthMismatchError,\n  BytesSizeMismatchError,\n  UnsupportedPackedAbiType,\n} from '../../errors/abi.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { Hex } from '../../types/misc.js'\nimport { isAddress } from '../address/isAddress.js'\nimport { concatHex } from '../data/concat.js'\nimport { pad } from '../data/pad.js'\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<\n  TPackedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n> = {\n  [K in keyof TPackedAbiTypes]: TPackedAbiTypes[K] extends AbiType\n    ? AbiParameterToPrimitiveType<{ type: TPackedAbiTypes[K] }>\n    : unknown\n}\n\nexport function encodePacked<\n  const TPackedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: TPackedAbiTypes, values: EncodePackedValues<TPackedAbiTypes>): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concatHex(data)\n}\n\nfunction encode<const TPackedAbiType extends PackedAbiType | unknown>(\n  type: TPackedAbiType,\n  value: EncodePackedValues<[TPackedAbiType]>[0],\n  isArray = false,\n): Hex {\n  if (type === 'address') {\n    const address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = parseInt(bits) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (parseInt(size) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: parseInt(size),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    const data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    if (data.length === 0) return '0x'\n    return concatHex(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}