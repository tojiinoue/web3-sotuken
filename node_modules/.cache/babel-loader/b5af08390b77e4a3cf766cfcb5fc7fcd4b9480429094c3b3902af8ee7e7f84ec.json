{"ast":null,"code":"/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').ElementChild} ElementChild\n */\n\nimport { extendedFilter } from 'bcp-47-match';\nimport { parse as commas } from 'comma-separated-tokens';\nimport { hasProperty } from 'hast-util-has-property';\nimport { whitespace } from 'hast-util-whitespace';\nimport fauxEsmNthCheck from 'nth-check';\nimport { zwitch } from 'zwitch';\nimport { queryToSelectors, walk } from './walk.js';\n\n/** @type {import('nth-check').default} */\n// @ts-expect-error\nconst nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck;\n\n/** @type {(rule: Rule | RulePseudo, element: Element, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */\nconst handle = zwitch('name', {\n  unknown: unknownPseudo,\n  invalid: invalidPseudo,\n  handlers: {\n    any: matches,\n    'any-link': anyLink,\n    blank,\n    checked,\n    dir,\n    disabled,\n    empty,\n    enabled,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    lang,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    matches,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-of-type': nthOfType,\n    'nth-last-of-type': nthLastOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    optional,\n    'read-only': readOnly,\n    'read-write': readWrite,\n    required,\n    root,\n    scope\n  }\n});\npseudo.needsIndex = ['any', 'first-child', 'first-of-type', 'last-child', 'last-of-type', 'matches', 'not', 'nth-child', 'nth-last-child', 'nth-of-type', 'nth-last-of-type', 'only-child', 'only-of-type'];\n\n/**\n * Check whether an element matches pseudo selectors.\n *\n * @param {Rule} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function pseudo(query, element, index, parent, state) {\n  const pseudos = query.pseudos;\n  let offset = -1;\n  while (++offset < pseudos.length) {\n    if (!handle(pseudos[offset], element, index, parent, state)) return false;\n  }\n  return true;\n}\n\n/**\n * Check whether an element matches an `:any-link` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction anyLink(_, element) {\n  return (element.tagName === 'a' || element.tagName === 'area' || element.tagName === 'link') && hasProperty(element, 'href');\n}\n\n/**\n * Check whether an element matches a `:blank` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction blank(_, element) {\n  return !someChildren(element, check);\n\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text' && !whitespace(child);\n  }\n}\n\n/**\n * Check whether an element matches a `:checked` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction checked(_, element) {\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\n    return Boolean(element.properties && (element.properties.type === 'checkbox' || element.properties.type === 'radio') && hasProperty(element, 'checked'));\n  }\n  if (element.tagName === 'option') {\n    return hasProperty(element, 'selected');\n  }\n  return false;\n}\n\n/**\n * Check whether an element matches a `:dir()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction dir(query, _1, _2, _3, state) {\n  return state.direction === query.value;\n}\n\n/**\n * Check whether an element matches a `:disabled` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction disabled(_, element) {\n  return (element.tagName === 'button' || element.tagName === 'input' || element.tagName === 'select' || element.tagName === 'textarea' || element.tagName === 'optgroup' || element.tagName === 'option' || element.tagName === 'menuitem' || element.tagName === 'fieldset') && hasProperty(element, 'disabled');\n}\n\n/**\n * Check whether an element matches an `:empty` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction empty(_, element) {\n  return !someChildren(element, check);\n\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text';\n  }\n}\n\n/**\n * Check whether an element matches an `:enabled` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\nfunction enabled(query, element) {\n  return !disabled(query, element);\n}\n\n/**\n * Check whether an element matches a `:first-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.elementIndex === 0;\n}\n\n/**\n * Check whether an element matches a `:first-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.typeIndex === 0;\n}\n\n/**\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction has(query, element, _1, _2, state) {\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  };\n  walk(childState, {\n    type: 'root',\n    children: element.children\n  });\n  return childState.results.length > 0;\n}\n\n/**\n * Check whether an element matches a `:lang()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lang(query, _1, _2, _3, state) {\n  return state.language !== '' && state.language !== undefined &&\n  // @ts-expect-error never `selectors`.\n  extendedFilter(state.language, commas(query.value)).length > 0;\n}\n\n/**\n * Check whether an element matches a `:last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);\n}\n\n/**\n * Check whether an element matches a `:last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return typeof state.typeIndex === 'number' && typeof state.typeCount === 'number' && state.typeIndex === state.typeCount - 1;\n}\n\n/**\n * Check whether an element `:matches` further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction matches(query, element, _, parent, state) {\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  };\n  walk(childState, element);\n  return childState.results[0] === element;\n}\n\n/**\n * Check whether an element does `:not` match further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction not(query, element, index, parent, state) {\n  return !matches(query, element, index, parent, state);\n}\n\n/**\n * Check whether an element matches an `:nth-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.elementIndex === 'number' && fn(state.elementIndex);\n}\n\n/**\n * Check whether an element matches an `:nth-last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return Boolean(typeof state.elementCount === 'number' && typeof state.elementIndex === 'number' && fn(state.elementCount - state.elementIndex - 1));\n}\n\n/**\n * Check whether an element matches a `:nth-last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.typeCount === 'number' && typeof state.typeIndex === 'number' && fn(state.typeCount - 1 - state.typeIndex);\n}\n\n/**\n * Check whether an element matches an `:nth-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query);\n  assertDeep(state, query);\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex);\n}\n\n/**\n * Check whether an element matches an `:only-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.elementCount === 1;\n}\n\n/**\n * Check whether an element matches an `:only-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query);\n  return state.typeCount === 1;\n}\n\n/**\n * Check whether an element matches an `:optional` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\nfunction optional(query, element) {\n  return !required(query, element);\n}\n\n/**\n * Check whether an element matches a `:read-only` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state);\n}\n\n/**\n * Check whether an element matches a `:read-write` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction readWrite(_, element, _1, _2, state) {\n  return element.tagName === 'input' || element.tagName === 'textarea' ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled') : Boolean(state.editableOrEditingHost);\n}\n\n/**\n * Check whether an element matches a `:required` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction required(_, element) {\n  return (element.tagName === 'input' || element.tagName === 'textarea' || element.tagName === 'select') && hasProperty(element, 'required');\n}\n\n/**\n * Check whether an element matches a `:root` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction root(_, element, _1, parent, state) {\n  return Boolean((!parent || parent.type === 'root') && state.schema && (state.schema.space === 'html' || state.schema.space === 'svg') && (element.tagName === 'html' || element.tagName === 'svg'));\n}\n\n/**\n * Check whether an element matches a `:scope` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction scope(_, element, _1, _2, state) {\n  return state.scopeElements.includes(element);\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  throw new Error('Invalid pseudo-selector');\n}\n\n/**\n * @param {unknown} query\n * @returns {never}\n */\nfunction unknownPseudo(query) {\n  // @ts-expect-error: indexable.\n  if (query.name) {\n    // @ts-expect-error: indexable.\n    throw new Error('Unknown pseudo-selector `' + query.name + '`');\n  }\n  throw new Error('Unexpected pseudo-element or empty pseudo-class');\n}\n\n/**\n * Check children.\n *\n * @param {Element} element\n * @param {(child: ElementChild) => boolean} check\n * @returns {boolean}\n */\nfunction someChildren(element, check) {\n  const children = element.children;\n  let index = -1;\n  while (++index < children.length) {\n    if (check(children[index])) return true;\n  }\n  return false;\n}\n\n/**\n * @param {SelectState} state\n * @param {RulePseudo} query\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent');\n  }\n}\n\n/**\n * @param {RulePseudo} query\n * @returns {(value: number) => boolean}\n */\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let fn = query._cachedFn;\n  if (!fn) {\n    // @ts-expect-error: always string.\n    fn = nthCheck(query.value);\n    // @ts-expect-error: cache.\n    query._cachedFn = fn;\n  }\n  return fn;\n}","map":{"version":3,"names":["extendedFilter","parse","commas","hasProperty","whitespace","fauxEsmNthCheck","zwitch","queryToSelectors","walk","nthCheck","default","handle","unknown","unknownPseudo","invalid","invalidPseudo","handlers","any","matches","anyLink","blank","checked","dir","disabled","empty","enabled","firstChild","firstOfType","has","lang","lastChild","lastOfType","not","nthChild","nthLastChild","nthOfType","nthLastOfType","onlyChild","onlyOfType","optional","readOnly","readWrite","required","root","scope","pseudo","needsIndex","query","element","index","parent","state","pseudos","offset","length","_","tagName","someChildren","check","child","type","Boolean","properties","_1","_2","_3","direction","value","assertDeep","elementIndex","typeIndex","childState","found","shallow","one","scopeElements","results","rootQuery","children","language","undefined","elementCount","typeCount","fn","getCachedNthCheck","editableOrEditingHost","schema","space","includes","Error","name","_cachedFn"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/hast-util-select/lib/pseudo.js"],"sourcesContent":["/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').ElementChild} ElementChild\n */\n\nimport {extendedFilter} from 'bcp-47-match'\nimport {parse as commas} from 'comma-separated-tokens'\nimport {hasProperty} from 'hast-util-has-property'\nimport {whitespace} from 'hast-util-whitespace'\nimport fauxEsmNthCheck from 'nth-check'\nimport {zwitch} from 'zwitch'\nimport {queryToSelectors, walk} from './walk.js'\n\n/** @type {import('nth-check').default} */\n// @ts-expect-error\nconst nthCheck = fauxEsmNthCheck.default || fauxEsmNthCheck\n\n/** @type {(rule: Rule | RulePseudo, element: Element, index: number | undefined, parent: Parent | undefined, state: SelectState) => boolean} */\nconst handle = zwitch('name', {\n  unknown: unknownPseudo,\n  invalid: invalidPseudo,\n  handlers: {\n    any: matches,\n    'any-link': anyLink,\n    blank,\n    checked,\n    dir,\n    disabled,\n    empty,\n    enabled,\n    'first-child': firstChild,\n    'first-of-type': firstOfType,\n    has,\n    lang,\n    'last-child': lastChild,\n    'last-of-type': lastOfType,\n    matches,\n    not,\n    'nth-child': nthChild,\n    'nth-last-child': nthLastChild,\n    'nth-of-type': nthOfType,\n    'nth-last-of-type': nthLastOfType,\n    'only-child': onlyChild,\n    'only-of-type': onlyOfType,\n    optional,\n    'read-only': readOnly,\n    'read-write': readWrite,\n    required,\n    root,\n    scope\n  }\n})\n\npseudo.needsIndex = [\n  'any',\n  'first-child',\n  'first-of-type',\n  'last-child',\n  'last-of-type',\n  'matches',\n  'not',\n  'nth-child',\n  'nth-last-child',\n  'nth-of-type',\n  'nth-last-of-type',\n  'only-child',\n  'only-of-type'\n]\n\n/**\n * Check whether an element matches pseudo selectors.\n *\n * @param {Rule} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function pseudo(query, element, index, parent, state) {\n  const pseudos = query.pseudos\n  let offset = -1\n\n  while (++offset < pseudos.length) {\n    if (!handle(pseudos[offset], element, index, parent, state)) return false\n  }\n\n  return true\n}\n\n/**\n * Check whether an element matches an `:any-link` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction anyLink(_, element) {\n  return (\n    (element.tagName === 'a' ||\n      element.tagName === 'area' ||\n      element.tagName === 'link') &&\n    hasProperty(element, 'href')\n  )\n}\n\n/**\n * Check whether an element matches a `:blank` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction blank(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return (\n      child.type === 'element' || (child.type === 'text' && !whitespace(child))\n    )\n  }\n}\n\n/**\n * Check whether an element matches a `:checked` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction checked(_, element) {\n  if (element.tagName === 'input' || element.tagName === 'menuitem') {\n    return Boolean(\n      element.properties &&\n        (element.properties.type === 'checkbox' ||\n          element.properties.type === 'radio') &&\n        hasProperty(element, 'checked')\n    )\n  }\n\n  if (element.tagName === 'option') {\n    return hasProperty(element, 'selected')\n  }\n\n  return false\n}\n\n/**\n * Check whether an element matches a `:dir()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction dir(query, _1, _2, _3, state) {\n  return state.direction === query.value\n}\n\n/**\n * Check whether an element matches a `:disabled` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction disabled(_, element) {\n  return (\n    (element.tagName === 'button' ||\n      element.tagName === 'input' ||\n      element.tagName === 'select' ||\n      element.tagName === 'textarea' ||\n      element.tagName === 'optgroup' ||\n      element.tagName === 'option' ||\n      element.tagName === 'menuitem' ||\n      element.tagName === 'fieldset') &&\n    hasProperty(element, 'disabled')\n  )\n}\n\n/**\n * Check whether an element matches an `:empty` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction empty(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text'\n  }\n}\n\n/**\n * Check whether an element matches an `:enabled` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\nfunction enabled(query, element) {\n  return !disabled(query, element)\n}\n\n/**\n * Check whether an element matches a `:first-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementIndex === 0\n}\n\n/**\n * Check whether an element matches a `:first-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeIndex === 0\n}\n\n/**\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction has(query, element, _1, _2, state) {\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  }\n\n  walk(childState, {type: 'root', children: element.children})\n\n  return childState.results.length > 0\n}\n\n/**\n * Check whether an element matches a `:lang()` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lang(query, _1, _2, _3, state) {\n  return (\n    state.language !== '' &&\n    state.language !== undefined &&\n    // @ts-expect-error never `selectors`.\n    extendedFilter(state.language, commas(query.value)).length > 0\n  )\n}\n\n/**\n * Check whether an element matches a `:last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return Boolean(\n    state.elementCount && state.elementIndex === state.elementCount - 1\n  )\n}\n\n/**\n * Check whether an element matches a `:last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.typeIndex === 'number' &&\n    typeof state.typeCount === 'number' &&\n    state.typeIndex === state.typeCount - 1\n  )\n}\n\n/**\n * Check whether an element `:matches` further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} _\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction matches(query, element, _, parent, state) {\n  /** @type {SelectState} */\n  const childState = {\n    ...state,\n    // Not found yet.\n    found: false,\n    // Do walk deep.\n    shallow: false,\n    // One result is enough.\n    one: true,\n    scopeElements: [element],\n    results: [],\n    rootQuery: queryToSelectors(query.value)\n  }\n\n  walk(childState, element)\n\n  return childState.results[0] === element\n}\n\n/**\n * Check whether an element does `:not` match further selectors.\n *\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction not(query, element, index, parent, state) {\n  return !matches(query, element, index, parent, state)\n}\n\n/**\n * Check whether an element matches an `:nth-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.elementIndex === 'number' && fn(state.elementIndex)\n}\n\n/**\n * Check whether an element matches an `:nth-last-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return Boolean(\n    typeof state.elementCount === 'number' &&\n      typeof state.elementIndex === 'number' &&\n      fn(state.elementCount - state.elementIndex - 1)\n  )\n}\n\n/**\n * Check whether an element matches a `:nth-last-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return (\n    typeof state.typeCount === 'number' &&\n    typeof state.typeIndex === 'number' &&\n    fn(state.typeCount - 1 - state.typeIndex)\n  )\n}\n\n/**\n * Check whether an element matches an `:nth-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  const fn = getCachedNthCheck(query)\n  assertDeep(state, query)\n  return typeof state.typeIndex === 'number' && fn(state.typeIndex)\n}\n\n/**\n * Check whether an element matches an `:only-child` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementCount === 1\n}\n\n/**\n * Check whether an element matches an `:only-of-type` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number | undefined} _2\n * @param {Parent | undefined} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeCount === 1\n}\n\n/**\n * Check whether an element matches an `:optional` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\nfunction optional(query, element) {\n  return !required(query, element)\n}\n\n/**\n * Check whether an element matches a `:read-only` pseudo.\n *\n * @param {RulePseudo} query\n * @param {Element} element\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state)\n}\n\n/**\n * Check whether an element matches a `:read-write` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction readWrite(_, element, _1, _2, state) {\n  return element.tagName === 'input' || element.tagName === 'textarea'\n    ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled')\n    : Boolean(state.editableOrEditingHost)\n}\n\n/**\n * Check whether an element matches a `:required` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction required(_, element) {\n  return (\n    (element.tagName === 'input' ||\n      element.tagName === 'textarea' ||\n      element.tagName === 'select') &&\n    hasProperty(element, 'required')\n  )\n}\n\n/**\n * Check whether an element matches a `:root` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction root(_, element, _1, parent, state) {\n  return Boolean(\n    (!parent || parent.type === 'root') &&\n      state.schema &&\n      (state.schema.space === 'html' || state.schema.space === 'svg') &&\n      (element.tagName === 'html' || element.tagName === 'svg')\n  )\n}\n\n/**\n * Check whether an element matches a `:scope` pseudo.\n *\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number | undefined} _1\n * @param {Parent | undefined} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction scope(_, element, _1, _2, state) {\n  return state.scopeElements.includes(element)\n}\n\n// Shouldn’t be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  throw new Error('Invalid pseudo-selector')\n}\n\n/**\n * @param {unknown} query\n * @returns {never}\n */\nfunction unknownPseudo(query) {\n  // @ts-expect-error: indexable.\n  if (query.name) {\n    // @ts-expect-error: indexable.\n    throw new Error('Unknown pseudo-selector `' + query.name + '`')\n  }\n\n  throw new Error('Unexpected pseudo-element or empty pseudo-class')\n}\n\n/**\n * Check children.\n *\n * @param {Element} element\n * @param {(child: ElementChild) => boolean} check\n * @returns {boolean}\n */\nfunction someChildren(element, check) {\n  const children = element.children\n  let index = -1\n\n  while (++index < children.length) {\n    if (check(children[index])) return true\n  }\n\n  return false\n}\n\n/**\n * @param {SelectState} state\n * @param {RulePseudo} query\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent')\n  }\n}\n\n/**\n * @param {RulePseudo} query\n * @returns {(value: number) => boolean}\n */\nfunction getCachedNthCheck(query) {\n  /** @type {(value: number) => boolean} */\n  // @ts-expect-error: cache.\n  let fn = query._cachedFn\n\n  if (!fn) {\n    // @ts-expect-error: always string.\n    fn = nthCheck(query.value)\n    // @ts-expect-error: cache.\n    query._cachedFn = fn\n  }\n\n  return fn\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}