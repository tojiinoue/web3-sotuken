{"ast":null,"code":"import { hexToBigInt } from '../../utils/encoding/fromHex.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlockNumber } from './getBlockNumber.js';\n/**\n * Watches and returns incoming block numbers.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlockNumberParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, watchBlockNumber, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlockNumber(client, {\n *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n * })\n */\nexport function watchBlockNumber(client, _ref) {\n  let {\n    emitOnBegin = false,\n    emitMissed = false,\n    onBlockNumber,\n    onError,\n    poll: poll_,\n    pollingInterval = client.pollingInterval\n  } = _ref;\n  const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';\n  let prevBlockNumber;\n  const pollBlockNumber = () => {\n    const observerId = stringify(['watchBlockNumber', client.uid, emitOnBegin, emitMissed, pollingInterval]);\n    return observe(observerId, {\n      onBlockNumber,\n      onError\n    }, emit => poll(async () => {\n      try {\n        const blockNumber = await getBlockNumber(client, {\n          cacheTime: 0\n        });\n        if (prevBlockNumber) {\n          // If the current block number is the same as the previous,\n          // we can skip.\n          if (blockNumber === prevBlockNumber) return;\n          // If we have missed out on some previous blocks, and the\n          // `emitMissed` flag is truthy, let's emit those blocks.\n          if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n              emit.onBlockNumber(i, prevBlockNumber);\n              prevBlockNumber = i;\n            }\n          }\n        }\n        // If the next block number is greater than the previous,\n        // it is not in the past, and we can emit the new block number.\n        if (!prevBlockNumber || blockNumber > prevBlockNumber) {\n          emit.onBlockNumber(blockNumber, prevBlockNumber);\n          prevBlockNumber = blockNumber;\n        }\n      } catch (err) {\n        var _emit$onError;\n        (_emit$onError = emit.onError) === null || _emit$onError === void 0 || _emit$onError.call(emit, err);\n      }\n    }, {\n      emitOnBegin,\n      interval: pollingInterval\n    }));\n  };\n  const subscribeBlockNumber = () => {\n    let active = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        const {\n          unsubscribe: unsubscribe_\n        } = await client.transport.subscribe({\n          params: ['newHeads'],\n          onData(data) {\n            var _data$result;\n            if (!active) return;\n            const blockNumber = hexToBigInt((_data$result = data.result) === null || _data$result === void 0 ? void 0 : _data$result.number);\n            onBlockNumber(blockNumber, prevBlockNumber);\n            prevBlockNumber = blockNumber;\n          },\n          onError(error) {\n            onError === null || onError === void 0 || onError(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError === null || onError === void 0 || onError(err);\n      }\n    })();\n    return unsubscribe;\n  };\n  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();\n}","map":{"version":3,"names":["hexToBigInt","observe","poll","stringify","getBlockNumber","watchBlockNumber","client","_ref","emitOnBegin","emitMissed","onBlockNumber","onError","poll_","pollingInterval","enablePolling","transport","type","prevBlockNumber","pollBlockNumber","observerId","uid","emit","blockNumber","cacheTime","i","err","_emit$onError","call","interval","subscribeBlockNumber","active","unsubscribe","unsubscribe_","subscribe","params","onData","data","_data$result","result","number","error"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/actions/public/watchBlockNumber.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetTransportConfig } from '../../types/transport.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport {\n  type GetBlockNumberReturnType,\n  getBlockNumber,\n} from './getBlockNumber.js'\n\nexport type OnBlockNumberParameter = GetBlockNumberReturnType\nexport type OnBlockNumberFn = (\n  blockNumber: OnBlockNumberParameter,\n  prevBlockNumber: OnBlockNumberParameter | undefined,\n) => void\n\nexport type PollOptions = {\n  /** Whether or not to emit the missed block numbers to the callback. */\n  emitMissed?: boolean\n  /** Whether or not to emit the latest block number to the callback when the subscription opens. */\n  emitOnBegin?: boolean\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n}\n\nexport type WatchBlockNumberParameters<\n  TTransport extends Transport = Transport,\n> = {\n  /** The callback to call when a new block number is received. */\n  onBlockNumber: OnBlockNumberFn\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n} & (GetTransportConfig<TTransport>['type'] extends 'webSocket'\n  ?\n      | {\n          emitMissed?: never\n          emitOnBegin?: never\n          /** Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`. */\n          poll?: false\n          pollingInterval?: never\n        }\n      | (PollOptions & { poll: true })\n  : PollOptions & { poll?: true })\n\nexport type WatchBlockNumberReturnType = () => void\n\n/**\n * Watches and returns incoming block numbers.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlockNumberParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, watchBlockNumber, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlockNumber(client, {\n *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n * })\n */\nexport function watchBlockNumber<\n  TChain extends Chain | undefined,\n  TTransport extends Transport,\n>(\n  client: Client<TTransport, TChain>,\n  {\n    emitOnBegin = false,\n    emitMissed = false,\n    onBlockNumber,\n    onError,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlockNumberParameters<TTransport>,\n): WatchBlockNumberReturnType {\n  const enablePolling =\n    typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket'\n\n  let prevBlockNumber: GetBlockNumberReturnType | undefined\n\n  const pollBlockNumber = () => {\n    const observerId = stringify([\n      'watchBlockNumber',\n      client.uid,\n      emitOnBegin,\n      emitMissed,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onBlockNumber, onError }, (emit) =>\n      poll(\n        async () => {\n          try {\n            const blockNumber = await getBlockNumber(client, { cacheTime: 0 })\n\n            if (prevBlockNumber) {\n              // If the current block number is the same as the previous,\n              // we can skip.\n              if (blockNumber === prevBlockNumber) return\n\n              // If we have missed out on some previous blocks, and the\n              // `emitMissed` flag is truthy, let's emit those blocks.\n              if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n                for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n                  emit.onBlockNumber(i, prevBlockNumber)\n                  prevBlockNumber = i\n                }\n              }\n            }\n\n            // If the next block number is greater than the previous,\n            // it is not in the past, and we can emit the new block number.\n            if (!prevBlockNumber || blockNumber > prevBlockNumber) {\n              emit.onBlockNumber(blockNumber, prevBlockNumber)\n              prevBlockNumber = blockNumber\n            }\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin,\n          interval: pollingInterval,\n        },\n      ),\n    )\n  }\n\n  const subscribeBlockNumber = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['newHeads'],\n          onData(data: any) {\n            if (!active) return\n            const blockNumber = hexToBigInt(data.result?.number)\n            onBlockNumber(blockNumber, prevBlockNumber)\n            prevBlockNumber = blockNumber\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return unsubscribe\n  }\n\n  return enablePolling ? pollBlockNumber() : subscribeBlockNumber()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}