{"ast":null,"code":"import { InvalidBytesBooleanError } from '../../errors/encoding.js';\nimport { trim } from '../data/trim.js';\nimport { assertSize, hexToBigInt, hexToNumber } from './fromHex.js';\nimport { bytesToHex } from './toHex.js';\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html\n * - Example: https://viem.sh/docs/utilities/fromBytes.html#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes(bytes, toOrOpts) {\n  const opts = typeof toOrOpts === 'string' ? {\n    to: toOrOpts\n  } : toOrOpts;\n  const to = opts.to;\n  if (to === 'number') return bytesToNumber(bytes, opts);\n  if (to === 'bigint') return bytesToBigint(bytes, opts);\n  if (to === 'boolean') return bytesToBool(bytes, opts);\n  if (to === 'string') return bytesToString(bytes, opts);\n  return bytesToHex(bytes, opts);\n}\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigint } from 'viem'\n * const data = bytesToBigint(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigint(bytes) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof opts.size !== 'undefined') assertSize(bytes, {\n    size: opts.size\n  });\n  const hex = bytesToHex(bytes, opts);\n  return hexToBigInt(hex);\n}\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(bytes_) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let bytes = bytes_;\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = trim(bytes);\n  }\n  if (bytes.length > 1 || bytes[0] > 1) throw new InvalidBytesBooleanError(bytes);\n  return Boolean(bytes[0]);\n}\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(bytes) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof opts.size !== 'undefined') assertSize(bytes, {\n    size: opts.size\n  });\n  const hex = bytesToHex(bytes, opts);\n  return hexToNumber(hex);\n}\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(bytes_) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let bytes = bytes_;\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = trim(bytes, {\n      dir: 'right'\n    });\n  }\n  return new TextDecoder().decode(bytes);\n}","map":{"version":3,"names":["InvalidBytesBooleanError","trim","assertSize","hexToBigInt","hexToNumber","bytesToHex","fromBytes","bytes","toOrOpts","opts","to","bytesToNumber","bytesToBigint","bytesToBool","bytesToString","arguments","length","undefined","size","hex","bytes_","Boolean","dir","TextDecoder","decode"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/utils/encoding/fromBytes.ts"],"sourcesContent":["import { InvalidBytesBooleanError } from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { trim } from '../data/trim.js'\n\nimport { assertSize, hexToBigInt, hexToNumber } from './fromHex.js'\nimport { bytesToHex } from './toHex.js'\n\nexport type FromBytesParameters<\n  TTo extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n> =\n  | TTo\n  | {\n      /** Size of the bytes. */\n      size?: number\n      /** Type to convert to. */\n      to: TTo\n    }\n\ntype FromBytesReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'hex'\n  ? Hex\n  : TTo extends 'bigint'\n  ? bigint\n  : TTo extends 'number'\n  ? number\n  : TTo extends 'boolean'\n  ? boolean\n  : never\n\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html\n * - Example: https://viem.sh/docs/utilities/fromBytes.html#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes<\n  TTo extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n>(\n  bytes: ByteArray,\n  toOrOpts: FromBytesParameters<TTo>,\n): FromBytesReturnType<TTo> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number')\n    return bytesToNumber(bytes, opts) as FromBytesReturnType<TTo>\n  if (to === 'bigint')\n    return bytesToBigint(bytes, opts) as FromBytesReturnType<TTo>\n  if (to === 'boolean')\n    return bytesToBool(bytes, opts) as FromBytesReturnType<TTo>\n  if (to === 'string')\n    return bytesToString(bytes, opts) as FromBytesReturnType<TTo>\n  return bytesToHex(bytes, opts) as FromBytesReturnType<TTo>\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean\n  /** Size of the bytes. */\n  size?: number\n}\n\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigint } from 'viem'\n * const data = bytesToBigint(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigint(\n  bytes: ByteArray,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToBigInt(hex)\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number\n}\n\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(\n  bytes_: ByteArray,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes)\n  }\n  if (bytes.length > 1 || bytes[0] > 1)\n    throw new InvalidBytesBooleanError(bytes)\n  return Boolean(bytes[0])\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts\n\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(\n  bytes: ByteArray,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToNumber(hex)\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number\n}\n\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes.html#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(\n  bytes_: ByteArray,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}