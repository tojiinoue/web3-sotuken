{"ast":null,"code":"import { AbiEventNotFoundError } from '../../errors/abi.js';\nimport { FilterTypeNotSupportedError } from '../../errors/log.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { getEventSelector } from '../hash/getEventSelector.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { encodeAbiParameters } from './encodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nimport { getAbiItem } from './getAbiItem.js';\nexport function encodeEventTopics(_ref) {\n  let {\n    abi,\n    eventName,\n    args\n  } = _ref;\n  let abiItem = abi[0];\n  if (eventName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: eventName\n    });\n    if (!abiItem) throw new AbiEventNotFoundError(eventName, {\n      docsPath: '/docs/contract/encodeEventTopics'\n    });\n  }\n  if (abiItem.type !== 'event') throw new AbiEventNotFoundError(undefined, {\n    docsPath: '/docs/contract/encodeEventTopics'\n  });\n  const definition = formatAbiItem(abiItem);\n  const signature = getEventSelector(definition);\n  let topics = [];\n  if (args && 'inputs' in abiItem) {\n    var _abiItem$inputs, _indexedInputs$map;\n    const indexedInputs = (_abiItem$inputs = abiItem.inputs) === null || _abiItem$inputs === void 0 ? void 0 : _abiItem$inputs.filter(param => 'indexed' in param && param.indexed);\n    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? (_indexedInputs$map = indexedInputs === null || indexedInputs === void 0 ? void 0 : indexedInputs.map(x => args[x.name])) !== null && _indexedInputs$map !== void 0 ? _indexedInputs$map : [] : [];\n    if (args_.length > 0) {\n      var _indexedInputs$map2;\n      topics = (_indexedInputs$map2 = indexedInputs === null || indexedInputs === void 0 ? void 0 : indexedInputs.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({\n        param,\n        value: args_[i][j]\n      })) : args_[i] ? encodeArg({\n        param,\n        value: args_[i]\n      }) : null)) !== null && _indexedInputs$map2 !== void 0 ? _indexedInputs$map2 : [];\n    }\n  }\n  return [signature, ...topics];\n}\nfunction encodeArg(_ref2) {\n  let {\n    param,\n    value\n  } = _ref2;\n  if (param.type === 'string' || param.type === 'bytes') return keccak256(toBytes(value));\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/)) throw new FilterTypeNotSupportedError(param.type);\n  return encodeAbiParameters([param], [value]);\n}","map":{"version":3,"names":["AbiEventNotFoundError","FilterTypeNotSupportedError","toBytes","getEventSelector","keccak256","encodeAbiParameters","formatAbiItem","getAbiItem","encodeEventTopics","_ref","abi","eventName","args","abiItem","name","docsPath","type","undefined","definition","signature","topics","_abiItem$inputs","_indexedInputs$map","indexedInputs","inputs","filter","param","indexed","args_","Array","isArray","Object","values","length","map","x","_indexedInputs$map2","i","_","j","encodeArg","value","_ref2","match"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/utils/abi/encodeEventTopics.ts"],"sourcesContent":["import type { Abi, AbiParameter, AbiParameterToPrimitiveType } from 'abitype'\n\nimport { AbiEventNotFoundError } from '../../errors/abi.js'\nimport { FilterTypeNotSupportedError } from '../../errors/log.js'\nimport type {\n  AbiItem,\n  EventDefinition,\n  GetEventArgs,\n  InferEventName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { getEventSelector } from '../hash/getEventSelector.js'\nimport { keccak256 } from '../hash/keccak256.js'\n\nimport { encodeAbiParameters } from './encodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nexport type EncodeEventTopicsParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  _EventName = InferEventName<TAbi, TEventName>,\n> = {\n  eventName?: _EventName\n} & (TEventName extends string\n  ? { abi: TAbi; args?: GetEventArgs<TAbi, TEventName> }\n  : _EventName extends string\n  ? { abi: [TAbi[number]]; args?: GetEventArgs<TAbi, _EventName> }\n  : never)\n\nexport function encodeEventTopics<\n  const TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined = undefined,\n>({ abi, eventName, args }: EncodeEventTopicsParameters<TAbi, TEventName>) {\n  let abiItem = abi[0] as AbiItem\n  if (eventName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: eventName,\n    } as GetAbiItemParameters)\n    if (!abiItem)\n      throw new AbiEventNotFoundError(eventName, {\n        docsPath: '/docs/contract/encodeEventTopics',\n      })\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, {\n      docsPath: '/docs/contract/encodeEventTopics',\n    })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = getEventSelector(definition as EventDefinition)\n\n  let topics: Hex[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n      ? indexedInputs?.map((x: any) => (args as any)[x.name]) ?? []\n      : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) =>\n          Array.isArray(args_[i])\n            ? args_[i].map((_: any, j: number) =>\n                encodeArg({ param, value: args_[i][j] }),\n              )\n            : args_[i]\n            ? encodeArg({ param, value: args_[i] })\n            : null,\n        ) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nfunction encodeArg({\n  param,\n  value,\n}: { param: AbiParameter; value: AbiParameterToPrimitiveType<AbiParameter> }) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}