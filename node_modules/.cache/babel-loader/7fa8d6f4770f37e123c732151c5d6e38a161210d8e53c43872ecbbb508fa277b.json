{"ast":null,"code":"import { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js';\nimport { size } from '../utils/data/size.js';\nimport { BaseError } from './base.js';\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor(_ref) {\n    let {\n      docsPath\n    } = _ref;\n    super(['A constructor was not found on the ABI.', 'Make sure you are using the correct ABI and that the constructor exists on it.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiConstructorNotFoundError'\n    });\n  }\n}\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor(_ref2) {\n    let {\n      docsPath\n    } = _ref2;\n    super(['Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.', 'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiConstructorParamsNotFoundError'\n    });\n  }\n}\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor(_ref3) {\n    let {\n      data,\n      size\n    } = _ref3;\n    super([`Data size of ${size} bytes is invalid.`, 'Size must be in increments of 32 bytes (size % 32 === 0).'].join('\\n'), {\n      metaMessages: [`Data: ${data} (${size} bytes)`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiDecodingDataSizeInvalidError'\n    });\n  }\n}\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  constructor(_ref4) {\n    let {\n      data,\n      params,\n      size\n    } = _ref4;\n    super([`Data size of ${size} bytes is too small for given parameters.`].join('\\n'), {\n      metaMessages: [`Params: (${formatAbiParams(params, {\n        includeName: true\n      })})`, `Data:   ${data} (${size} bytes)`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiDecodingDataSizeTooSmallError'\n    });\n    Object.defineProperty(this, \"data\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"params\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"size\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.data = data;\n    this.params = params;\n    this.size = size;\n  }\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiDecodingZeroDataError'\n    });\n  }\n}\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor(_ref5) {\n    let {\n      expectedLength,\n      givenLength,\n      type\n    } = _ref5;\n    super([`ABI encoding array length mismatch for type ${type}.`, `Expected length: ${expectedLength}`, `Given length: ${givenLength}`].join('\\n'));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiEncodingArrayLengthMismatchError'\n    });\n  }\n}\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor(_ref6) {\n    let {\n      expectedSize,\n      value\n    } = _ref6;\n    super(`Size of bytes \"${value}\" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiEncodingBytesSizeMismatchError'\n    });\n  }\n}\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor(_ref7) {\n    let {\n      expectedLength,\n      givenLength\n    } = _ref7;\n    super(['ABI encoding params/values length mismatch.', `Expected length (params): ${expectedLength}`, `Given length (values): ${givenLength}`].join('\\n'));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiEncodingLengthMismatchError'\n    });\n  }\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName, _ref8) {\n    let {\n      docsPath\n    } = _ref8;\n    super([`Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`, 'Cannot encode error result without knowing what the parameter types are.', 'Make sure you are using the correct ABI and that the inputs exist on it.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiErrorInputsNotFoundError'\n    });\n  }\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(errorName) {\n    let {\n      docsPath\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super([`Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`, 'Make sure you are using the correct ABI and that the error exists on it.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiErrorNotFoundError'\n    });\n  }\n}\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  constructor(signature, _ref9) {\n    let {\n      docsPath\n    } = _ref9;\n    super([`Encoded error signature \"${signature}\" not found on ABI.`, 'Make sure you are using the correct ABI and that the error exists on it.', `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiErrorSignatureNotFoundError'\n    });\n    Object.defineProperty(this, \"signature\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.signature = signature;\n  }\n}\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor(_ref10) {\n    let {\n      docsPath\n    } = _ref10;\n    super('Cannot extract event signature from empty topics.', {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiEventSignatureEmptyTopicsError'\n    });\n  }\n}\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature, _ref11) {\n    let {\n      docsPath\n    } = _ref11;\n    super([`Encoded event signature \"${signature}\" not found on ABI.`, 'Make sure you are using the correct ABI and that the event exists on it.', `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiEventSignatureNotFoundError'\n    });\n  }\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(eventName) {\n    let {\n      docsPath\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super([`Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`, 'Make sure you are using the correct ABI and that the event exists on it.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiEventNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(functionName) {\n    let {\n      docsPath\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super([`Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`, 'Make sure you are using the correct ABI and that the function exists on it.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiFunctionNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName, _ref12) {\n    let {\n      docsPath\n    } = _ref12;\n    super([`Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`, 'Cannot decode function result without knowing what the parameter types are.', 'Make sure you are using the correct ABI and that the function exists on it.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiFunctionOutputsNotFoundError'\n    });\n  }\n}\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature, _ref13) {\n    let {\n      docsPath\n    } = _ref13;\n    super([`Encoded function signature \"${signature}\" not found on ABI.`, 'Make sure you are using the correct ABI and that the function exists on it.', `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'AbiFunctionSignatureNotFoundError'\n    });\n  }\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor(_ref14) {\n    let {\n      expectedSize,\n      givenSize\n    } = _ref14;\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'BytesSizeMismatchError'\n    });\n  }\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  constructor(_ref15) {\n    let {\n      abiItem,\n      data,\n      params,\n      size\n    } = _ref15;\n    super([`Data size of ${size} bytes is too small for non-indexed event parameters.`].join('\\n'), {\n      metaMessages: [`Params: (${formatAbiParams(params, {\n        includeName: true\n      })})`, `Data:   ${data} (${size} bytes)`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'DecodeLogDataMismatch'\n    });\n    Object.defineProperty(this, \"abiItem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"data\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"params\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"size\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.abiItem = abiItem;\n    this.data = data;\n    this.params = params;\n    this.size = size;\n  }\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  constructor(_ref16) {\n    let {\n      abiItem,\n      param\n    } = _ref16;\n    super([`Expected a topic for indexed event parameter${param.name ? ` \"${param.name}\"` : ''} on event \"${formatAbiItem(abiItem, {\n      includeName: true\n    })}\".`].join('\\n'));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'DecodeLogTopicsMismatch'\n    });\n    Object.defineProperty(this, \"abiItem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.abiItem = abiItem;\n  }\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type, _ref17) {\n    let {\n      docsPath\n    } = _ref17;\n    super([`Type \"${type}\" is not a valid encoding type.`, 'Please provide a valid ABI type.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'InvalidAbiEncodingType'\n    });\n  }\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type, _ref18) {\n    let {\n      docsPath\n    } = _ref18;\n    super([`Type \"${type}\" is not a valid decoding type.`, 'Please provide a valid ABI type.'].join('\\n'), {\n      docsPath\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'InvalidAbiDecodingType'\n    });\n  }\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'InvalidArrayError'\n    });\n  }\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type) {\n    super([`\"${type}\" is not a valid definition type.`, 'Valid types: \"function\", \"event\", \"error\"'].join('\\n'));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'InvalidDefinitionTypeError'\n    });\n  }\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type) {\n    super(`Type \"${type}\" is not supported for packed encoding.`);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'UnsupportedPackedAbiType'\n    });\n  }\n}","map":{"version":3,"names":["formatAbiItem","formatAbiParams","size","BaseError","AbiConstructorNotFoundError","constructor","_ref","docsPath","join","Object","defineProperty","AbiConstructorParamsNotFoundError","_ref2","AbiDecodingDataSizeInvalidError","_ref3","data","metaMessages","AbiDecodingDataSizeTooSmallError","_ref4","params","includeName","AbiDecodingZeroDataError","AbiEncodingArrayLengthMismatchError","_ref5","expectedLength","givenLength","type","AbiEncodingBytesSizeMismatchError","_ref6","expectedSize","value","AbiEncodingLengthMismatchError","_ref7","AbiErrorInputsNotFoundError","errorName","_ref8","AbiErrorNotFoundError","arguments","length","undefined","AbiErrorSignatureNotFoundError","signature","_ref9","AbiEventSignatureEmptyTopicsError","_ref10","AbiEventSignatureNotFoundError","_ref11","AbiEventNotFoundError","eventName","AbiFunctionNotFoundError","functionName","AbiFunctionOutputsNotFoundError","_ref12","AbiFunctionSignatureNotFoundError","_ref13","BytesSizeMismatchError","_ref14","givenSize","DecodeLogDataMismatch","_ref15","abiItem","DecodeLogTopicsMismatch","_ref16","param","name","InvalidAbiEncodingTypeError","_ref17","InvalidAbiDecodingTypeError","_ref18","InvalidArrayError","InvalidDefinitionTypeError","UnsupportedPackedAbiType"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/errors/abi.ts"],"sourcesContent":["import type { AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport class AbiConstructorNotFoundError extends BaseError {\n  override name = 'AbiConstructorNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  override name = 'AbiConstructorParamsNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  override name = 'AbiDecodingDataSizeInvalidError'\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      { metaMessages: [`Data: ${data} (${size} bytes)`] },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  override name = 'AbiDecodingDataSizeTooSmallError'\n\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport class AbiDecodingZeroDataError extends BaseError {\n  override name = 'AbiDecodingZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  override name = 'AbiEncodingBytesSizeMismatchError'\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  override name = 'AbiErrorInputsNotFoundError'\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorNotFoundError extends BaseError {\n  override name = 'AbiErrorNotFoundError'\n  constructor(errorName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  override name = 'AbiErrorSignatureNotFoundError'\n\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  override name = 'AbiEventSignatureEmptyTopicsError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n    })\n  }\n}\n\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  override name = 'AbiEventSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiEventNotFoundError extends BaseError {\n  override name = 'AbiEventNotFoundError'\n  constructor(eventName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionNotFoundError extends BaseError {\n  override name = 'AbiFunctionNotFoundError'\n  constructor(functionName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  override name = 'AbiFunctionOutputsNotFoundError'\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  override name = 'AbiFunctionSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class BytesSizeMismatchError extends BaseError {\n  override name = 'BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\nexport class DecodeLogDataMismatch extends BaseError {\n  override name = 'DecodeLogDataMismatch'\n\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport class DecodeLogTopicsMismatch extends BaseError {\n  override name = 'DecodeLogTopicsMismatch'\n\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  override name = 'InvalidAbiEncodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  override name = 'InvalidAbiDecodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidArrayError extends BaseError {\n  override name = 'InvalidArrayError'\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'))\n  }\n}\n\nexport class InvalidDefinitionTypeError extends BaseError {\n  override name = 'InvalidDefinitionTypeError'\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class UnsupportedPackedAbiType extends BaseError {\n  override name = 'UnsupportedPackedAbiType'\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}