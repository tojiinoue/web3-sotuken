{"ast":null,"code":"import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getTypesForEIP712Domain, validateTypedData } from '../../utils/typedData.js';\n/**\n * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256(\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)))`\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n */\nexport async function signTypedData(client, _ref) {\n  let {\n    account: account_ = client.account,\n    domain,\n    message,\n    primaryType,\n    types: types_\n  } = _ref;\n  if (!account_) throw new AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/signTypedData'\n  });\n  const account = parseAccount(account_);\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({\n      domain\n    }),\n    ...types_\n  };\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  if (account.type === 'local') return account.signTypedData({\n    domain,\n    primaryType,\n    types,\n    message\n  });\n  const typedData = stringify({\n    domain: domain !== null && domain !== void 0 ? domain : {},\n    primaryType,\n    types,\n    message\n  }, (_, value) => isHex(value) ? value.toLowerCase() : value);\n  return client.request({\n    method: 'eth_signTypedData_v4',\n    params: [account.address, typedData]\n  });\n}","map":{"version":3,"names":["parseAccount","AccountNotFoundError","isHex","stringify","getTypesForEIP712Domain","validateTypedData","signTypedData","client","_ref","account","account_","domain","message","primaryType","types","types_","docsPath","EIP712Domain","type","typedData","_","value","toLowerCase","request","method","params","address"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/actions/wallet/signTypedData.ts"],"sourcesContent":["import type { TypedData } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { isHex } from '../../utils/data/isHex.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../../utils/typedData.js'\n\nexport type SignTypedDataParameters<\n  TTypedData extends TypedData | { [key: string]: unknown } = TypedData,\n  TPrimaryType extends string = string,\n  TAccount extends Account | undefined = undefined,\n> = GetAccountParameter<TAccount> &\n  TypedDataDefinition<TTypedData, TPrimaryType>\n\nexport type SignTypedDataReturnType = Hex\n\n/**\n * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256(\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)))`\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n */\nexport async function signTypedData<\n  const TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string,\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  {\n    account: account_ = client.account,\n    domain,\n    message,\n    primaryType,\n    types: types_,\n  }: SignTypedDataParameters<TTypedData, TPrimaryType, TAccount>,\n): Promise<SignTypedDataReturnType> {\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signTypedData',\n    })\n  const account = parseAccount(account_)\n\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...(types_ as TTypedData),\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  } as TypedDataDefinition)\n\n  if (account.type === 'local')\n    return account.signTypedData({\n      domain,\n      primaryType,\n      types,\n      message,\n    } as TypedDataDefinition)\n\n  const typedData = stringify(\n    { domain: domain ?? {}, primaryType, types, message },\n    (_, value) => (isHex(value) ? value.toLowerCase() : value),\n  )\n  return client.request({\n    method: 'eth_signTypedData_v4',\n    params: [account.address, typedData],\n  })\n}\n"],"mappings":"AAGA,SAASA,YAAY,QAAQ,sCAAsC;AAGnE,SAASC,oBAAoB,QAAQ,yBAAyB;AAK9D,SAASC,KAAK,QAAQ,2BAA2B;AACjD,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SACEC,uBAAuB,EACvBC,iBAAiB,QACZ,0BAA0B;AAWjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkGA,OAAO,eAAeC,aAAaA,CAMjCC,MAA2C,EAAAC,IAAA,EAOmB;EAAA,IAN9D;IACEC,OAAO,EAAEC,QAAQ,GAAGH,MAAM,CAACE,OAAO;IAClCE,MAAM;IACNC,OAAO;IACPC,WAAW;IACXC,KAAK,EAAEC;EAAM,CAC+C,GAAAP,IAAA;EAE9D,IAAI,CAACE,QAAQ,EACX,MAAM,IAAIT,oBAAoB,CAAC;IAC7Be,QAAQ,EAAE;GACX,CAAC;EACJ,MAAMP,OAAO,GAAGT,YAAY,CAACU,QAAQ,CAAC;EAEtC,MAAMI,KAAK,GAAG;IACZG,YAAY,EAAEb,uBAAuB,CAAC;MAAEO;IAAM,CAAE,CAAC;IACjD,GAAII;GACL;EAED;EACA;EACAV,iBAAiB,CAAC;IAChBM,MAAM;IACNC,OAAO;IACPC,WAAW;IACXC;GACsB,CAAC;EAEzB,IAAIL,OAAO,CAACS,IAAI,KAAK,OAAO,EAC1B,OAAOT,OAAO,CAACH,aAAa,CAAC;IAC3BK,MAAM;IACNE,WAAW;IACXC,KAAK;IACLF;GACsB,CAAC;EAE3B,MAAMO,SAAS,GAAGhB,SAAS,CACzB;IAAEQ,MAAM,EAAEA,MAAM,aAANA,MAAM,cAANA,MAAM,GAAI,EAAE;IAAEE,WAAW;IAAEC,KAAK;IAAEF;EAAO,CAAE,EACrD,CAACQ,CAAC,EAAEC,KAAK,KAAMnB,KAAK,CAACmB,KAAK,CAAC,GAAGA,KAAK,CAACC,WAAW,EAAE,GAAGD,KAAM,CAC3D;EACD,OAAOd,MAAM,CAACgB,OAAO,CAAC;IACpBC,MAAM,EAAE,sBAAsB;IAC9BC,MAAM,EAAE,CAAChB,OAAO,CAACiB,OAAO,EAAEP,SAAS;GACpC,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}