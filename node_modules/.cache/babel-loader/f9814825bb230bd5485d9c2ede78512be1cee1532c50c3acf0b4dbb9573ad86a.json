{"ast":null,"code":"export const promiseCache = /*#__PURE__*/new Map();\nexport const responseCache = /*#__PURE__*/new Map();\nexport function getCache(cacheKey) {\n  const buildCache = (cacheKey, cache) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: data => cache.set(cacheKey, data)\n  });\n  const promise = buildCache(cacheKey, promiseCache);\n  const response = buildCache(cacheKey, responseCache);\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response\n  };\n}\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache(fn, _ref) {\n  let {\n    cacheKey,\n    cacheTime = Infinity\n  } = _ref;\n  const cache = getCache(cacheKey);\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) return response.data;\n  }\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n  try {\n    const data = await promise;\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({\n      created: new Date(),\n      data\n    });\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}","map":{"version":3,"names":["promiseCache","Map","responseCache","getCache","cacheKey","buildCache","cache","clear","delete","get","set","data","promise","response","withCache","fn","_ref","cacheTime","Infinity","age","Date","getTime","created"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/promise/withCache.ts"],"sourcesContent":["export const promiseCache = /*#__PURE__*/ new Map()\nexport const responseCache = /*#__PURE__*/ new Map()\n\nexport function getCache<TData>(cacheKey: string) {\n  const buildCache = <TData>(cacheKey: string, cache: Map<string, TData>) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: (data: TData) => cache.set(cacheKey, data),\n  })\n\n  const promise = buildCache<Promise<TData>>(cacheKey, promiseCache)\n  const response = buildCache<{ created: Date; data: TData }>(\n    cacheKey,\n    responseCache,\n  )\n\n  return {\n    clear: () => {\n      promise.clear()\n      response.clear()\n    },\n    promise,\n    response,\n  }\n}\n\nexport type WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number\n}\n\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache<TData>(\n  fn: () => Promise<TData>,\n  { cacheKey, cacheTime = Infinity }: WithCacheParameters,\n) {\n  const cache = getCache<TData>(cacheKey)\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get()\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime()\n    if (age < cacheTime) return response.data\n  }\n\n  let promise = cache.promise.get()\n  if (!promise) {\n    promise = fn()\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise)\n  }\n\n  try {\n    const data = await promise\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data })\n\n    return data\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear()\n  }\n}\n"],"mappings":"AAAA,OAAO,MAAMA,YAAY,GAAG,aAAc,IAAIC,GAAG,EAAE;AACnD,OAAO,MAAMC,aAAa,GAAG,aAAc,IAAID,GAAG,EAAE;AAEpD,OAAM,SAAUE,QAAQA,CAAQC,QAAgB;EAC9C,MAAMC,UAAU,GAAGA,CAAQD,QAAgB,EAAEE,KAAyB,MAAM;IAC1EC,KAAK,EAAEA,CAAA,KAAMD,KAAK,CAACE,MAAM,CAACJ,QAAQ,CAAC;IACnCK,GAAG,EAAEA,CAAA,KAAMH,KAAK,CAACG,GAAG,CAACL,QAAQ,CAAC;IAC9BM,GAAG,EAAGC,IAAW,IAAKL,KAAK,CAACI,GAAG,CAACN,QAAQ,EAAEO,IAAI;GAC/C,CAAC;EAEF,MAAMC,OAAO,GAAGP,UAAU,CAAiBD,QAAQ,EAAEJ,YAAY,CAAC;EAClE,MAAMa,QAAQ,GAAGR,UAAU,CACzBD,QAAQ,EACRF,aAAa,CACd;EAED,OAAO;IACLK,KAAK,EAAEA,CAAA,KAAK;MACVK,OAAO,CAACL,KAAK,EAAE;MACfM,QAAQ,CAACN,KAAK,EAAE;IAClB,CAAC;IACDK,OAAO;IACPC;GACD;AACH;AASA;;;;AAIA,OAAO,eAAeC,SAASA,CAC7BC,EAAwB,EAAAC,IAAA,EAC+B;EAAA,IAAvD;IAAEZ,QAAQ;IAAEa,SAAS,GAAGC;EAAQ,CAAuB,GAAAF,IAAA;EAEvD,MAAMV,KAAK,GAAGH,QAAQ,CAAQC,QAAQ,CAAC;EAEvC;EACA;EACA;EACA,MAAMS,QAAQ,GAAGP,KAAK,CAACO,QAAQ,CAACJ,GAAG,EAAE;EACrC,IAAII,QAAQ,IAAII,SAAS,GAAG,CAAC,EAAE;IAC7B,MAAME,GAAG,GAAG,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE,GAAGR,QAAQ,CAACS,OAAO,CAACD,OAAO,EAAE;IAC7D,IAAIF,GAAG,GAAGF,SAAS,EAAE,OAAOJ,QAAQ,CAACF,IAAI;;EAG3C,IAAIC,OAAO,GAAGN,KAAK,CAACM,OAAO,CAACH,GAAG,EAAE;EACjC,IAAI,CAACG,OAAO,EAAE;IACZA,OAAO,GAAGG,EAAE,EAAE;IAEd;IACA;IACAT,KAAK,CAACM,OAAO,CAACF,GAAG,CAACE,OAAO,CAAC;;EAG5B,IAAI;IACF,MAAMD,IAAI,GAAG,MAAMC,OAAO;IAE1B;IACA;IACAN,KAAK,CAACO,QAAQ,CAACH,GAAG,CAAC;MAAEY,OAAO,EAAE,IAAIF,IAAI,EAAE;MAAET;IAAI,CAAE,CAAC;IAEjD,OAAOA,IAAI;GACZ,SAAS;IACR;IACA;IACAL,KAAK,CAACM,OAAO,CAACL,KAAK,EAAE;;AAEzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}