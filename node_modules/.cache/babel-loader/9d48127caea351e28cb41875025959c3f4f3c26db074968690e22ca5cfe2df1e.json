{"ast":null,"code":"/**\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Space} Space\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport { html, svg } from 'property-information';\nimport { queryToSelectors, walk } from './walk.js';\nimport { parse } from './parse.js';\n\n/**\n * Check that the given `node` matches `selector`.\n *\n * This only checks the element itself, not the surrounding tree.\n * Thus, nesting in selectors is not supported (`p b`, `p > b`), neither are\n * selectors like `:first-child`, etc.\n * This only checks that the given element matches the selector.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [node]\n *   Node that might match `selector`, should be an element.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {boolean}\n *   Whether `node` matches `selector`.\n */\nexport function matches(selector, node, space) {\n  const state = createState(selector, node, space);\n  state.one = true;\n  state.shallow = true;\n  walk(state, node || undefined);\n  return state.results.length > 0;\n}\n\n/**\n * Select the first element that matches `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Element | null}\n *   First element in `tree` that matches `selector` or `null` if nothing is\n *   found.\n *   This could be `tree` itself.\n */\nexport function select(selector, tree, space) {\n  const state = createState(selector, tree, space);\n  state.one = true;\n  walk(state, tree || undefined);\n  // To do in major: return `undefined` instead.\n  return state.results[0] || null;\n}\n\n/**\n * Select all elements that match `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Array<Element>}\n *   Elements in `tree` that match `selector`.\n *   This could include `tree` itself.\n */\nexport function selectAll(selector, tree, space) {\n  const state = createState(selector, tree, space);\n  walk(state, tree || undefined);\n  return state.results;\n}\n\n/**\n * @param {string} selector\n *   Tree to search.\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {SelectState} SelectState\n */\nfunction createState(selector, tree, space) {\n  return {\n    // State of the query.\n    rootQuery: queryToSelectors(parse(selector)),\n    results: [],\n    // @ts-expect-error assume elements.\n    scopeElements: tree ? tree.type === 'root' ? tree.children : [tree] : [],\n    one: false,\n    shallow: false,\n    found: false,\n    // State in the tree.\n    schema: space === 'svg' ? svg : html,\n    language: undefined,\n    direction: 'ltr',\n    editableOrEditingHost: false,\n    typeIndex: undefined,\n    elementIndex: undefined,\n    typeCount: undefined,\n    elementCount: undefined\n  };\n}","map":{"version":3,"names":["html","svg","queryToSelectors","walk","parse","matches","selector","node","space","state","createState","one","shallow","undefined","results","length","select","tree","selectAll","rootQuery","scopeElements","type","children","found","schema","language","direction","editableOrEditingHost","typeIndex","elementIndex","typeCount","elementCount"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/hast-util-select/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Space} Space\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport {html, svg} from 'property-information'\nimport {queryToSelectors, walk} from './walk.js'\nimport {parse} from './parse.js'\n\n/**\n * Check that the given `node` matches `selector`.\n *\n * This only checks the element itself, not the surrounding tree.\n * Thus, nesting in selectors is not supported (`p b`, `p > b`), neither are\n * selectors like `:first-child`, etc.\n * This only checks that the given element matches the selector.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [node]\n *   Node that might match `selector`, should be an element.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {boolean}\n *   Whether `node` matches `selector`.\n */\nexport function matches(selector, node, space) {\n  const state = createState(selector, node, space)\n  state.one = true\n  state.shallow = true\n  walk(state, node || undefined)\n  return state.results.length > 0\n}\n\n/**\n * Select the first element that matches `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Element | null}\n *   First element in `tree` that matches `selector` or `null` if nothing is\n *   found.\n *   This could be `tree` itself.\n */\nexport function select(selector, tree, space) {\n  const state = createState(selector, tree, space)\n  state.one = true\n  walk(state, tree || undefined)\n  // To do in major: return `undefined` instead.\n  return state.results[0] || null\n}\n\n/**\n * Select all elements that match `selector` in the given `tree`.\n * Searches the tree in *preorder*.\n *\n * @param {string} selector\n *   CSS selector, such as (`h1`, `a, b`).\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {Array<Element>}\n *   Elements in `tree` that match `selector`.\n *   This could include `tree` itself.\n */\nexport function selectAll(selector, tree, space) {\n  const state = createState(selector, tree, space)\n  walk(state, tree || undefined)\n  return state.results\n}\n\n/**\n * @param {string} selector\n *   Tree to search.\n * @param {Node | null | undefined} [tree]\n *   Tree to search.\n * @param {Space | null | undefined} [space='html']\n *   Name of namespace (`'svg'` or `'html'`).\n * @returns {SelectState} SelectState\n */\nfunction createState(selector, tree, space) {\n  return {\n    // State of the query.\n    rootQuery: queryToSelectors(parse(selector)),\n    results: [],\n    // @ts-expect-error assume elements.\n    scopeElements: tree ? (tree.type === 'root' ? tree.children : [tree]) : [],\n    one: false,\n    shallow: false,\n    found: false,\n    // State in the tree.\n    schema: space === 'svg' ? svg : html,\n    language: undefined,\n    direction: 'ltr',\n    editableOrEditingHost: false,\n    typeIndex: undefined,\n    elementIndex: undefined,\n    typeCount: undefined,\n    elementCount: undefined\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,IAAI,EAAEC,GAAG,QAAO,sBAAsB;AAC9C,SAAQC,gBAAgB,EAAEC,IAAI,QAAO,WAAW;AAChD,SAAQC,KAAK,QAAO,YAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,OAAOA,CAACC,QAAQ,EAAEC,IAAI,EAAEC,KAAK,EAAE;EAC7C,MAAMC,KAAK,GAAGC,WAAW,CAACJ,QAAQ,EAAEC,IAAI,EAAEC,KAAK,CAAC;EAChDC,KAAK,CAACE,GAAG,GAAG,IAAI;EAChBF,KAAK,CAACG,OAAO,GAAG,IAAI;EACpBT,IAAI,CAACM,KAAK,EAAEF,IAAI,IAAIM,SAAS,CAAC;EAC9B,OAAOJ,KAAK,CAACK,OAAO,CAACC,MAAM,GAAG,CAAC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CAACV,QAAQ,EAAEW,IAAI,EAAET,KAAK,EAAE;EAC5C,MAAMC,KAAK,GAAGC,WAAW,CAACJ,QAAQ,EAAEW,IAAI,EAAET,KAAK,CAAC;EAChDC,KAAK,CAACE,GAAG,GAAG,IAAI;EAChBR,IAAI,CAACM,KAAK,EAAEQ,IAAI,IAAIJ,SAAS,CAAC;EAC9B;EACA,OAAOJ,KAAK,CAACK,OAAO,CAAC,CAAC,CAAC,IAAI,IAAI;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,SAASA,CAACZ,QAAQ,EAAEW,IAAI,EAAET,KAAK,EAAE;EAC/C,MAAMC,KAAK,GAAGC,WAAW,CAACJ,QAAQ,EAAEW,IAAI,EAAET,KAAK,CAAC;EAChDL,IAAI,CAACM,KAAK,EAAEQ,IAAI,IAAIJ,SAAS,CAAC;EAC9B,OAAOJ,KAAK,CAACK,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,WAAWA,CAACJ,QAAQ,EAAEW,IAAI,EAAET,KAAK,EAAE;EAC1C,OAAO;IACL;IACAW,SAAS,EAAEjB,gBAAgB,CAACE,KAAK,CAACE,QAAQ,CAAC,CAAC;IAC5CQ,OAAO,EAAE,EAAE;IACX;IACAM,aAAa,EAAEH,IAAI,GAAIA,IAAI,CAACI,IAAI,KAAK,MAAM,GAAGJ,IAAI,CAACK,QAAQ,GAAG,CAACL,IAAI,CAAC,GAAI,EAAE;IAC1EN,GAAG,EAAE,KAAK;IACVC,OAAO,EAAE,KAAK;IACdW,KAAK,EAAE,KAAK;IACZ;IACAC,MAAM,EAAEhB,KAAK,KAAK,KAAK,GAAGP,GAAG,GAAGD,IAAI;IACpCyB,QAAQ,EAAEZ,SAAS;IACnBa,SAAS,EAAE,KAAK;IAChBC,qBAAqB,EAAE,KAAK;IAC5BC,SAAS,EAAEf,SAAS;IACpBgB,YAAY,EAAEhB,SAAS;IACvBiB,SAAS,EAAEjB,SAAS;IACpBkB,YAAY,EAAElB;EAChB,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}