{"ast":null,"code":"import { BaseError } from '../../errors/base.js';\nimport { isHex } from '../data/isHex.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nimport { numberToHex } from './toHex.js';\nconst encoder = /*#__PURE__*/new TextEncoder();\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html\n * - Example: https://viem.sh/docs/utilities/toBytes.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToBytes(value, opts);\n  if (typeof value === 'boolean') return boolToBytes(value, opts);\n  if (isHex(value)) return hexToBytes(value, opts);\n  return stringToBytes(value, opts);\n}\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const bytes = new Uint8Array(1);\n  bytes[0] = Number(value);\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    return pad(bytes, {\n      size: opts.size\n    });\n  }\n  return bytes;\n}\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let hex = hex_;\n  if (opts.size) {\n    assertSize(hex, {\n      size: opts.size\n    });\n    hex = pad(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  let hexString = hex.slice(2);\n  if (hexString.length % 2) hexString = `0${hexString}`;\n  const bytes = new Uint8Array(hexString.length / 2);\n  for (let index = 0; index < bytes.length; index++) {\n    const start = index * 2;\n    const hexByte = hexString.slice(start, start + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new BaseError(`Invalid byte sequence (\"${hexByte}\" in \"${hexString}\").`);\n    bytes[index] = byte;\n  }\n  return bytes;\n}\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value, opts) {\n  const hex = numberToHex(value, opts);\n  return hexToBytes(hex);\n}\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const bytes = encoder.encode(value);\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    return pad(bytes, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return bytes;\n}","map":{"version":3,"names":["BaseError","isHex","pad","assertSize","numberToHex","encoder","TextEncoder","toBytes","value","opts","arguments","length","undefined","numberToBytes","boolToBytes","hexToBytes","stringToBytes","bytes","Uint8Array","Number","size","hex_","hex","dir","hexString","slice","index","start","hexByte","byte","parseInt","isNaN","encode"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/utils/encoding/toBytes.ts"],"sourcesContent":["import { BaseError } from '../../errors/base.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { isHex } from '../data/isHex.js'\nimport { pad } from '../data/pad.js'\n\nimport { assertSize } from './fromHex.js'\nimport { type NumberToHexOpts, numberToHex } from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html\n * - Example: https://viem.sh/docs/utilities/toBytes.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToHexOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const bytes = new Uint8Array(hexString.length / 2)\n  for (let index = 0; index < bytes.length; index++) {\n    const start = index * 2\n    const hexByte = hexString.slice(start, start + 2)\n    const byte = Number.parseInt(hexByte, 16)\n    if (Number.isNaN(byte) || byte < 0)\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexByte}\" in \"${hexString}\").`,\n      )\n    bytes[index] = byte\n  }\n  return bytes\n}\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value: bigint | number, opts?: NumberToHexOpts) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}