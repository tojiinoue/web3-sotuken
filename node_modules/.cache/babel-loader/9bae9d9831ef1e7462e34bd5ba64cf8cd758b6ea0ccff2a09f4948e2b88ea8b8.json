{"ast":null,"code":"import { AbiDecodingDataSizeTooSmallError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { getEventSelector } from '../hash/getEventSelector.js';\nimport { decodeAbiParameters } from './decodeAbiParameters.js';\nimport { formatAbiItem } from './formatAbiItem.js';\nconst docsPath = '/docs/contract/decodeEventLog';\nexport function decodeEventLog(_ref) {\n  let {\n    abi,\n    data,\n    strict: strict_,\n    topics\n  } = _ref;\n  const strict = strict_ !== null && strict_ !== void 0 ? strict_ : true;\n  const [signature, ...argTopics] = topics;\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({\n    docsPath\n  });\n  const abiItem = abi.find(x => x.type === 'event' && signature === getEventSelector(formatAbiItem(x)));\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event') throw new AbiEventSignatureNotFoundError(signature, {\n    docsPath\n  });\n  const {\n    name,\n    inputs\n  } = abiItem;\n  const isUnnamed = inputs === null || inputs === void 0 ? void 0 : inputs.some(x => !('name' in x && x.name));\n  let args = isUnnamed ? [] : {};\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter(x => 'indexed' in x && x.indexed);\n  if (argTopics.length > 0) {\n    for (let i = 0; i < indexedInputs.length; i++) {\n      const param = indexedInputs[i];\n      const topic = argTopics[i];\n      if (!topic) throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param\n      });\n      args[param.name || i] = decodeTopic({\n        param,\n        value: topic\n      });\n    }\n  }\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter(x => !('indexed' in x && x.indexed));\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data);\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData];else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name] = decodedData[i];\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (err instanceof AbiDecodingDataSizeTooSmallError) throw new DecodeLogDataMismatch({\n            abiItem,\n            data: err.data,\n            params: err.params,\n            size: err.size\n          });\n          throw err;\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0\n      });\n    }\n  }\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined\n  };\n}\nfunction decodeTopic(_ref2) {\n  let {\n    param,\n    value\n  } = _ref2;\n  if (param.type === 'string' || param.type === 'bytes' || param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/)) return value;\n  const decodedArg = decodeAbiParameters([param], value) || [];\n  return decodedArg[0];\n}","map":{"version":3,"names":["AbiDecodingDataSizeTooSmallError","AbiEventSignatureEmptyTopicsError","AbiEventSignatureNotFoundError","DecodeLogDataMismatch","DecodeLogTopicsMismatch","getEventSelector","decodeAbiParameters","formatAbiItem","docsPath","decodeEventLog","_ref","abi","data","strict","strict_","topics","signature","argTopics","abiItem","find","x","type","name","inputs","isUnnamed","some","args","indexedInputs","filter","indexed","length","i","param","topic","decodeTopic","value","nonIndexedInputs","decodedData","err","params","size","eventName","Object","values","undefined","_ref2","match","decodedArg"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/abi/decodeEventLog.ts"],"sourcesContent":["import type { Abi, AbiParameter, ExtractAbiEventNames } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiEventSignatureEmptyTopicsError,\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type {\n  EventDefinition,\n  GetEventArgsFromTopics,\n  InferEventName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getEventSelector } from '../hash/getEventSelector.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n> = {\n  abi: TAbi\n  data?: TData\n  eventName?: InferEventName<TAbi, TEventName>\n  strict?: TStrict\n  topics: [signature: Hex, ...args: TTopics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n  _EventNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiEventNames<TAbi>\n    : string,\n> = TEventName extends _EventNames[number]\n  ? Prettify<\n      {\n        eventName: TEventName\n      } & GetEventArgsFromTopics<TAbi, TEventName, TTopics, TData, TStrict>\n    >\n  : {\n      [TName in _EventNames]: Prettify<\n        {\n          eventName: TName\n        } & GetEventArgsFromTopics<TAbi, TName, TTopics, TData, TStrict>\n      >\n    }[_EventNames]\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined = undefined,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n>({\n  abi,\n  data,\n  strict: strict_,\n  topics,\n}: DecodeEventLogParameters<\n  TAbi,\n  TEventName,\n  TTopics,\n  TData,\n  TStrict\n>): DecodeEventLogReturnType<TAbi, TEventName, TTopics, TData, TStrict> {\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature)\n    throw new AbiEventSignatureEmptyTopicsError({\n      docsPath,\n    })\n  const abiItem = (abi as Abi).find(\n    (x) =>\n      x.type === 'event' &&\n      signature === getEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, {\n      docsPath,\n    })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  if (argTopics.length > 0) {\n    for (let i = 0; i < indexedInputs.length; i++) {\n      const param = indexedInputs[i]\n      const topic = argTopics[i]\n      if (!topic)\n        throw new DecodeLogTopicsMismatch({\n          abiItem,\n          param: param as AbiParameter & { indexed: boolean },\n        })\n      args[param.name || i] = decodeTopic({ param, value: topic })\n    }\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (err instanceof AbiDecodingDataSizeTooSmallError)\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: err.data,\n              params: err.params,\n              size: err.size,\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<\n    TAbi,\n    TEventName,\n    TTopics,\n    TData,\n    TStrict\n  >\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}