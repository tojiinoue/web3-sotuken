{"ast":null,"code":"import _wrapRegExp from \"/Users/toji.inoue/Desktop/web3-sotuken/node_modules/@babel/runtime/helpers/esm/wrapRegExp.js\";\nimport { readContract } from '../../../actions/public/readContract.js';\nimport { EnsAvatarInvalidMetadataError, EnsAvatarInvalidNftUriError, EnsAvatarUnsupportedNamespaceError, EnsAvatarUriResolutionError } from '../../../errors/ens.js';\nconst networkRegex = /*#__PURE__*/_wrapRegExp(/(https?:\\/\\/[^\\/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(\\/)?(ipfs\\/|ipns\\/)?([\\w\\-.]+)(\\/.*)?/, {\n  protocol: 1,\n  root: 2,\n  subpath: 3,\n  target: 4,\n  subtarget: 5\n});\nconst ipfsHashRegex = /*#__PURE__*/_wrapRegExp(/^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/([\\w\\-.]+))?(\\/.*)?$/, {\n  target: 3,\n  subtarget: 4\n});\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/;\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;\nexport async function isImageUri(uri) {\n  try {\n    const res = await fetch(uri, {\n      method: 'HEAD'\n    });\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type');\n      return contentType === null || contentType === void 0 ? void 0 : contentType.startsWith('image/');\n    }\n    return false;\n  } catch (error) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false;\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    // biome-ignore lint/suspicious/noPrototypeBuiltins:\n    if (!globalThis.hasOwnProperty('Image')) return false;\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise(resolve => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(true);\n      };\n      img.onerror = () => {\n        resolve(false);\n      };\n      img.src = uri;\n    });\n  }\n}\nexport function getGateway(custom, defaultGateway) {\n  if (!custom) return defaultGateway;\n  if (custom.endsWith('/')) return custom.slice(0, -1);\n  return custom;\n}\nexport function resolveAvatarUri(_ref) {\n  let {\n    uri,\n    gatewayUrls\n  } = _ref;\n  const isEncoded = base64Regex.test(uri);\n  if (isEncoded) return {\n    uri,\n    isOnChain: true,\n    isEncoded\n  };\n  const ipfsGateway = getGateway(gatewayUrls === null || gatewayUrls === void 0 ? void 0 : gatewayUrls.ipfs, 'https://ipfs.io');\n  const arweaveGateway = getGateway(gatewayUrls === null || gatewayUrls === void 0 ? void 0 : gatewayUrls.arweave, 'https://arweave.net');\n  const networkRegexMatch = uri.match(networkRegex);\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = ''\n  } = (networkRegexMatch === null || networkRegexMatch === void 0 ? void 0 : networkRegexMatch.groups) || {};\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';\n  const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri;\n    if (gatewayUrls !== null && gatewayUrls !== void 0 && gatewayUrls.arweave) replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls === null || gatewayUrls === void 0 ? void 0 : gatewayUrls.arweave);\n    return {\n      uri: replacedUri,\n      isOnChain: false,\n      isEncoded: false\n    };\n  }\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n      isOnChain: false,\n      isEncoded: false\n    };\n  } else if (protocol === 'ar:/' && target) {\n    return {\n      uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n      isOnChain: false,\n      isEncoded: false\n    };\n  }\n  let parsedUri = uri.replace(dataURIRegex, '');\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;\n  }\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false\n    };\n  }\n  throw new EnsAvatarUriResolutionError({\n    uri\n  });\n}\nexport function getJsonImage(data) {\n  // validation check for json data, must include one of theses properties\n  if (typeof data !== 'object' || !('image' in data) && !('image_url' in data) && !('image_data' in data)) {\n    throw new EnsAvatarInvalidMetadataError({\n      data\n    });\n  }\n  return data.image || data.image_url || data.image_data;\n}\nexport async function getMetadataAvatarUri(_ref2) {\n  let {\n    gatewayUrls,\n    uri\n  } = _ref2;\n  try {\n    const res = await fetch(uri).then(res => res.json());\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res)\n    });\n    return image;\n  } catch {\n    throw new EnsAvatarUriResolutionError({\n      uri\n    });\n  }\n}\nexport async function parseAvatarUri(_ref3) {\n  let {\n    gatewayUrls,\n    uri\n  } = _ref3;\n  const {\n    uri: resolvedURI,\n    isOnChain\n  } = resolveAvatarUri({\n    uri,\n    gatewayUrls\n  });\n  if (isOnChain) return resolvedURI;\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI);\n  if (isImage) return resolvedURI;\n  throw new EnsAvatarUriResolutionError({\n    uri\n  });\n}\nexport function parseNftUri(uri_) {\n  let uri = uri_;\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/');\n  }\n  const [reference, asset_namespace, tokenID] = uri.split('/');\n  const [eip_namespace, chainID] = reference.split(':');\n  const [erc_namespace, contractAddress] = asset_namespace.split(':');\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155') throw new EnsAvatarInvalidNftUriError({\n    reason: 'Only EIP-155 supported'\n  });\n  if (!chainID) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Chain ID not found'\n  });\n  if (!contractAddress) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Contract address not found'\n  });\n  if (!tokenID) throw new EnsAvatarInvalidNftUriError({\n    reason: 'Token ID not found'\n  });\n  if (!erc_namespace) throw new EnsAvatarInvalidNftUriError({\n    reason: 'ERC namespace not found'\n  });\n  return {\n    chainID: parseInt(chainID),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress,\n    tokenID\n  };\n}\nexport async function getNftTokenUri(client, _ref4) {\n  let {\n    nft\n  } = _ref4;\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [{\n        name: 'tokenURI',\n        type: 'function',\n        stateMutability: 'view',\n        inputs: [{\n          name: 'tokenId',\n          type: 'uint256'\n        }],\n        outputs: [{\n          name: '',\n          type: 'string'\n        }]\n      }],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)]\n    });\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [{\n        name: 'uri',\n        type: 'function',\n        stateMutability: 'view',\n        inputs: [{\n          name: '_id',\n          type: 'uint256'\n        }],\n        outputs: [{\n          name: '',\n          type: 'string'\n        }]\n      }],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)]\n    });\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({\n    namespace: nft.namespace\n  });\n}","map":{"version":3,"names":["readContract","EnsAvatarInvalidMetadataError","EnsAvatarInvalidNftUriError","EnsAvatarUnsupportedNamespaceError","EnsAvatarUriResolutionError","networkRegex","_wrapRegExp","protocol","root","subpath","target","subtarget","ipfsHashRegex","base64Regex","dataURIRegex","isImageUri","uri","res","fetch","method","status","contentType","headers","get","startsWith","error","response","globalThis","hasOwnProperty","Promise","resolve","img","Image","onload","onerror","src","getGateway","custom","defaultGateway","endsWith","slice","resolveAvatarUri","_ref","gatewayUrls","isEncoded","test","isOnChain","ipfsGateway","ipfs","arweaveGateway","arweave","networkRegexMatch","match","groups","isIPNS","isIPFS","replacedUri","replace","parsedUri","btoa","getJsonImage","data","image","image_url","image_data","getMetadataAvatarUri","_ref2","then","json","parseAvatarUri","_ref3","resolvedURI","isImage","parseNftUri","uri_","reference","asset_namespace","tokenID","split","eip_namespace","chainID","erc_namespace","contractAddress","toLowerCase","reason","parseInt","namespace","getNftTokenUri","client","_ref4","nft","address","abi","name","type","stateMutability","inputs","outputs","functionName","args","BigInt"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/ens/avatar/utils.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport { readContract } from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport {\n  EnsAvatarInvalidMetadataError,\n  EnsAvatarInvalidNftUriError,\n  EnsAvatarUnsupportedNamespaceError,\n  EnsAvatarUriResolutionError,\n} from '../../../errors/ens.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\ntype UriItem = {\n  uri: string\n  isOnChain: boolean\n  isEncoded: boolean\n}\n\nconst networkRegex =\n  /(?<protocol>https?:\\/\\/[^\\/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/\nconst ipfsHashRegex =\n  /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/\n\nexport async function isImageUri(uri: string) {\n  try {\n    const res = await fetch(uri, { method: 'HEAD' })\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type')\n      return contentType?.startsWith('image/')\n    }\n    return false\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    // biome-ignore lint/suspicious/noPrototypeBuiltins:\n    if (!globalThis.hasOwnProperty('Image')) return false\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image()\n      img.onload = () => {\n        resolve(true)\n      }\n      img.onerror = () => {\n        resolve(false)\n      }\n      img.src = uri\n    })\n  }\n}\n\nexport function getGateway(custom: string | undefined, defaultGateway: string) {\n  if (!custom) return defaultGateway\n  if (custom.endsWith('/')) return custom.slice(0, -1)\n  return custom\n}\n\nexport function resolveAvatarUri({\n  uri,\n  gatewayUrls,\n}: {\n  uri: string\n  gatewayUrls?: AssetGatewayUrls | undefined\n}): UriItem {\n  const isEncoded = base64Regex.test(uri)\n  if (isEncoded) return { uri, isOnChain: true, isEncoded }\n\n  const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io')\n  const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net')\n\n  const networkRegexMatch = uri.match(networkRegex)\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = '',\n  } = networkRegexMatch?.groups || {}\n\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/'\n  const isIPFS =\n    protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri)\n\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri\n    if (gatewayUrls?.arweave)\n      replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave)\n    return { uri: replacedUri, isOnChain: false, isEncoded: false }\n  }\n\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  } else if (protocol === 'ar:/' && target) {\n    return {\n      uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  let parsedUri = uri.replace(dataURIRegex, '')\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`\n  }\n\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false,\n    }\n  }\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\nexport function getJsonImage(data: any) {\n  // validation check for json data, must include one of theses properties\n  if (\n    typeof data !== 'object' ||\n    (!('image' in data) && !('image_url' in data) && !('image_data' in data))\n  ) {\n    throw new EnsAvatarInvalidMetadataError({ data })\n  }\n\n  return data.image || data.image_url || data.image_data\n}\n\nexport async function getMetadataAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  try {\n    const res = await fetch(uri).then((res) => res.json())\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res),\n    })\n    return image\n  } catch {\n    throw new EnsAvatarUriResolutionError({ uri })\n  }\n}\n\nexport async function parseAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls })\n  if (isOnChain) return resolvedURI\n\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI)\n  if (isImage) return resolvedURI\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\ntype ParsedNft = {\n  chainID: number\n  namespace: string\n  contractAddress: Address\n  tokenID: string\n}\n\nexport function parseNftUri(uri_: string): ParsedNft {\n  let uri = uri_\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/')\n  }\n\n  const [reference, asset_namespace, tokenID] = uri.split('/')\n  const [eip_namespace, chainID] = reference.split(':')\n  const [erc_namespace, contractAddress] = asset_namespace.split(':')\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' })\n  if (!chainID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' })\n  if (!contractAddress)\n    throw new EnsAvatarInvalidNftUriError({\n      reason: 'Contract address not found',\n    })\n  if (!tokenID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' })\n  if (!erc_namespace)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' })\n\n  return {\n    chainID: parseInt(chainID),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress as Address,\n    tokenID,\n  }\n}\n\nexport async function getNftTokenUri<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { nft }: { nft: ParsedNft },\n) {\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'tokenURI',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: 'tokenId', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'uri',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: '_id', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}