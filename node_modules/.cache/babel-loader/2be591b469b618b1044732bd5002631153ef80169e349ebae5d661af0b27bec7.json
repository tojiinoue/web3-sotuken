{"ast":null,"code":"import { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { getContractError } from '../../utils/errors/getContractError.js';\nimport { call } from './call.js';\n/**\n * Calls a read-only function on a contract, and returns the response.\n *\n * - Docs: https://viem.sh/docs/contract/readContract.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/reading-contracts\n *\n * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n *\n * @param client - Client to use\n * @param parameters - {@link ReadContractParameters}\n * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { readContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await readContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n *   functionName: 'balanceOf',\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // 424122n\n */\nexport async function readContract(client, _ref) {\n  let {\n    abi,\n    address,\n    args,\n    functionName,\n    ...callRequest\n  } = _ref;\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName\n  });\n  try {\n    const {\n      data\n    } = await call(client, {\n      data: calldata,\n      to: address,\n      ...callRequest\n    });\n    return decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x'\n    });\n  } catch (err) {\n    throw getContractError(err, {\n      abi: abi,\n      address,\n      args,\n      docsPath: '/docs/contract/readContract',\n      functionName\n    });\n  }\n}","map":{"version":3,"names":["decodeFunctionResult","encodeFunctionData","getContractError","call","readContract","client","_ref","abi","address","args","functionName","callRequest","calldata","data","to","err","docsPath"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/actions/public/readContract.ts"],"sourcesContent":["import type { Abi } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionConfig,\n  ContractFunctionResult,\n} from '../../types/contract.js'\nimport {\n  type DecodeFunctionResultParameters,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\n\nimport { type CallParameters, call } from './call.js'\n\nexport type ReadContractParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = Pick<CallParameters, 'account' | 'blockNumber' | 'blockTag'> &\n  ContractFunctionConfig<TAbi, TFunctionName, 'view' | 'pure'>\n\nexport type ReadContractReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = ContractFunctionResult<TAbi, TFunctionName>\n\n/**\n * Calls a read-only function on a contract, and returns the response.\n *\n * - Docs: https://viem.sh/docs/contract/readContract.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/reading-contracts\n *\n * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n *\n * @param client - Client to use\n * @param parameters - {@link ReadContractParameters}\n * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { readContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await readContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n *   functionName: 'balanceOf',\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // 424122n\n */\nexport async function readContract<\n  TChain extends Chain | undefined,\n  const TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n>(\n  client: Client<Transport, TChain>,\n  {\n    abi,\n    address,\n    args,\n    functionName,\n    ...callRequest\n  }: ReadContractParameters<TAbi, TFunctionName>,\n): Promise<ReadContractReturnType<TAbi, TFunctionName>> {\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  try {\n    const { data } = await call(client, {\n      data: calldata,\n      to: address,\n      ...callRequest,\n    } as unknown as CallParameters)\n    return decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    } as DecodeFunctionResultParameters<\n      TAbi,\n      TFunctionName\n    >) as ReadContractReturnType<TAbi, TFunctionName>\n  } catch (err) {\n    throw getContractError(err as BaseError, {\n      abi: abi as Abi,\n      address,\n      args,\n      docsPath: '/docs/contract/readContract',\n      functionName,\n    })\n  }\n}\n"],"mappings":"AAUA,SAEEA,oBAAoB,QACf,yCAAyC;AAChD,SAEEC,kBAAkB,QACb,uCAAuC;AAC9C,SAASC,gBAAgB,QAAQ,wCAAwC;AAEzE,SAA8BC,IAAI,QAAQ,WAAW;AAarD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,OAAO,eAAeC,YAAYA,CAKhCC,MAAiC,EAAAC,IAAA,EAOa;EAAA,IAN9C;IACEC,GAAG;IACHC,OAAO;IACPC,IAAI;IACJC,YAAY;IACZ,GAAGC;EAAW,CAC8B,GAAAL,IAAA;EAE9C,MAAMM,QAAQ,GAAGX,kBAAkB,CAAC;IAClCM,GAAG;IACHE,IAAI;IACJC;GAC+D,CAAC;EAClE,IAAI;IACF,MAAM;MAAEG;IAAI,CAAE,GAAG,MAAMV,IAAI,CAACE,MAAM,EAAE;MAClCQ,IAAI,EAAED,QAAQ;MACdE,EAAE,EAAEN,OAAO;MACX,GAAGG;KACyB,CAAC;IAC/B,OAAOX,oBAAoB,CAAC;MAC1BO,GAAG;MACHE,IAAI;MACJC,YAAY;MACZG,IAAI,EAAEA,IAAI,IAAI;KAIf,CAAgD;GAClD,CAAC,OAAOE,GAAG,EAAE;IACZ,MAAMb,gBAAgB,CAACa,GAAgB,EAAE;MACvCR,GAAG,EAAEA,GAAU;MACfC,OAAO;MACPC,IAAI;MACJO,QAAQ,EAAE,6BAA6B;MACvCN;KACD,CAAC;;AAEN"},"metadata":{},"sourceType":"module","externalDependencies":[]}