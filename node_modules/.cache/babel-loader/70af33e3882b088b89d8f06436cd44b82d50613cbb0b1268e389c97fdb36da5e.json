{"ast":null,"code":"export function selectWord(_ref) {\n  var {\n    text,\n    selection\n  } = _ref;\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\nexport function getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n  var isWordDelimiter = c => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  var start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  var end = text.length;\n\n  // iterate to the left\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (var _i = position; _i < text.length; _i++) {\n    if (isWordDelimiter(text[_i])) {\n      end = _i;\n      break;\n    }\n  }\n  return {\n    start,\n    end\n  };\n}","map":{"version":3,"names":["selectWord","_ref","text","selection","length","start","end","getSurroundingWord","getBreaksNeededForEmptyLineBefore","startPosition","neededBreaks","isInFirstLine","i","charCodeAt","getBreaksNeededForEmptyLineAfter","isInLastLine","position","Error","isWordDelimiter","c","_i"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/@uiw/react-md-editor/esm/utils/markdownUtils.js"],"sourcesContent":["export function selectWord(_ref) {\n  var {\n    text,\n    selection\n  } = _ref;\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = '';\n  }\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\nexport function getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n  var isWordDelimiter = c => c === ' ' || c.charCodeAt(0) === 10;\n\n  // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n  var start = 0;\n  // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n  var end = text.length;\n\n  // iterate to the left\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  }\n\n  // iterate to the right\n  for (var _i = position; _i < text.length; _i++) {\n    if (isWordDelimiter(text[_i])) {\n      end = _i;\n      break;\n    }\n  }\n  return {\n    start,\n    end\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}