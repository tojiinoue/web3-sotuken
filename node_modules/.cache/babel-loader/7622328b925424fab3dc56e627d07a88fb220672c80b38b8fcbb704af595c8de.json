{"ast":null,"code":"import { createContractEventFilter } from './public/createContractEventFilter.js';\nimport { estimateContractGas } from './public/estimateContractGas.js';\nimport { getContractEvents } from './public/getContractEvents.js';\nimport { readContract } from './public/readContract.js';\nimport { simulateContract } from './public/simulateContract.js';\nimport { watchContractEvent } from './public/watchContractEvent.js';\nimport { writeContract } from './wallet/writeContract.js';\n/**\n * Gets type-safe interface for performing contract-related actions with a specific `abi` and `address`.\n *\n * - Docs https://viem.sh/docs/contract/getContract.html\n *\n * Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properites every time you perform contract actions, e.g. [`readContract`](https://viem.sh/docs/contract/readContract.html), [`writeContract`](https://viem.sh/docs/contract/writeContract.html), [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas.html), etc.\n *\n * @example\n * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const publicClient = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const contract = getContract({\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi([\n *     'function balanceOf(address owner) view returns (uint256)',\n *     'function ownerOf(uint256 tokenId) view returns (address)',\n *     'function totalSupply() view returns (uint256)',\n *   ]),\n *   publicClient,\n * })\n */\nexport function getContract(_ref) {\n  let {\n    abi,\n    address,\n    publicClient,\n    walletClient\n  } = _ref;\n  const hasPublicClient = publicClient !== undefined && publicClient !== null;\n  const hasWalletClient = walletClient !== undefined && walletClient !== null;\n  const contract = {};\n  let hasReadFunction = false;\n  let hasWriteFunction = false;\n  let hasEvent = false;\n  for (const item of abi) {\n    if (item.type === 'function') {\n      if (item.stateMutability === 'view' || item.stateMutability === 'pure') hasReadFunction = true;else hasWriteFunction = true;\n    } else if (item.type === 'event') hasEvent = true;\n    // Exit early if all flags are `true`\n    if (hasReadFunction && hasWriteFunction && hasEvent) break;\n  }\n  if (hasPublicClient) {\n    if (hasReadFunction) contract.read = new Proxy({}, {\n      get(_, functionName) {\n        return function () {\n          for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n            parameters[_key] = arguments[_key];\n          }\n          const {\n            args,\n            options\n          } = getFunctionParameters(parameters);\n          return readContract(publicClient, {\n            abi,\n            address,\n            functionName,\n            args,\n            ...options\n          });\n        };\n      }\n    });\n    if (hasWriteFunction) contract.simulate = new Proxy({}, {\n      get(_, functionName) {\n        return function () {\n          for (var _len2 = arguments.length, parameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            parameters[_key2] = arguments[_key2];\n          }\n          const {\n            args,\n            options\n          } = getFunctionParameters(parameters);\n          return simulateContract(publicClient, {\n            abi,\n            address,\n            functionName,\n            args,\n            ...options\n          });\n        };\n      }\n    });\n    if (hasEvent) {\n      contract.createEventFilter = new Proxy({}, {\n        get(_, eventName) {\n          return function () {\n            const abiEvent = abi.find(x => x.type === 'event' && x.name === eventName);\n            for (var _len3 = arguments.length, parameters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              parameters[_key3] = arguments[_key3];\n            }\n            const {\n              args,\n              options\n            } = getEventParameters(parameters, abiEvent);\n            return createContractEventFilter(publicClient, {\n              abi,\n              address,\n              eventName,\n              args,\n              ...options\n            });\n          };\n        }\n      });\n      contract.getEvents = new Proxy({}, {\n        get(_, eventName) {\n          return function () {\n            const abiEvent = abi.find(x => x.type === 'event' && x.name === eventName);\n            for (var _len4 = arguments.length, parameters = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              parameters[_key4] = arguments[_key4];\n            }\n            const {\n              args,\n              options\n            } = getEventParameters(parameters, abiEvent);\n            return getContractEvents(publicClient, {\n              abi,\n              address,\n              eventName,\n              args,\n              ...options\n            });\n          };\n        }\n      });\n      contract.watchEvent = new Proxy({}, {\n        get(_, eventName) {\n          return function () {\n            const abiEvent = abi.find(x => x.type === 'event' && x.name === eventName);\n            for (var _len5 = arguments.length, parameters = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n              parameters[_key5] = arguments[_key5];\n            }\n            const {\n              args,\n              options\n            } = getEventParameters(parameters, abiEvent);\n            return watchContractEvent(publicClient, {\n              abi,\n              address,\n              eventName,\n              args,\n              ...options\n            });\n          };\n        }\n      });\n    }\n  }\n  if (hasWalletClient) {\n    if (hasWriteFunction) contract.write = new Proxy({}, {\n      get(_, functionName) {\n        return function () {\n          for (var _len6 = arguments.length, parameters = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n            parameters[_key6] = arguments[_key6];\n          }\n          const {\n            args,\n            options\n          } = getFunctionParameters(parameters);\n          return writeContract(walletClient, {\n            abi,\n            address,\n            functionName,\n            args,\n            ...options\n          });\n        };\n      }\n    });\n  }\n  if (hasPublicClient || hasWalletClient) if (hasWriteFunction) contract.estimateGas = new Proxy({}, {\n    get(_, functionName) {\n      return function () {\n        var _options$account;\n        for (var _len7 = arguments.length, parameters = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n          parameters[_key7] = arguments[_key7];\n        }\n        const {\n          args,\n          options\n        } = getFunctionParameters(parameters);\n        const client = publicClient !== null && publicClient !== void 0 ? publicClient : walletClient;\n        return estimateContractGas(client, {\n          abi,\n          address,\n          functionName,\n          args,\n          ...options,\n          account: (_options$account = options.account) !== null && _options$account !== void 0 ? _options$account : walletClient.account\n        });\n      };\n    }\n  });\n  contract.address = address;\n  contract.abi = abi;\n  return contract;\n}\n/**\n * @internal exporting for testing only\n */\nexport function getFunctionParameters(values) {\n  var _ref2;\n  const hasArgs = values.length && Array.isArray(values[0]);\n  const args = hasArgs ? values[0] : [];\n  const options = (_ref2 = hasArgs ? values[1] : values[0]) !== null && _ref2 !== void 0 ? _ref2 : {};\n  return {\n    args,\n    options\n  };\n}\n/**\n * @internal exporting for testing only\n */\nexport function getEventParameters(values, abiEvent) {\n  var _ref3;\n  let hasArgs = false;\n  // If first item is array, must be `args`\n  if (Array.isArray(values[0])) hasArgs = true;\n  // Check if first item is `args` or `options`\n  else if (values.length === 1) {\n    // if event has indexed inputs, must have `args`\n    hasArgs = abiEvent.inputs.some(x => x.indexed);\n    // If there are two items in array, must have `args`\n  } else if (values.length === 2) {\n    hasArgs = true;\n  }\n  const args = hasArgs ? values[0] : undefined;\n  const options = (_ref3 = hasArgs ? values[1] : values[0]) !== null && _ref3 !== void 0 ? _ref3 : {};\n  return {\n    args,\n    options\n  };\n}","map":{"version":3,"names":["createContractEventFilter","estimateContractGas","getContractEvents","readContract","simulateContract","watchContractEvent","writeContract","getContract","_ref","abi","address","publicClient","walletClient","hasPublicClient","undefined","hasWalletClient","contract","hasReadFunction","hasWriteFunction","hasEvent","item","type","stateMutability","read","Proxy","get","_","functionName","_len","arguments","length","parameters","Array","_key","args","options","getFunctionParameters","simulate","_len2","_key2","createEventFilter","eventName","abiEvent","find","x","name","_len3","_key3","getEventParameters","getEvents","_len4","_key4","watchEvent","_len5","_key5","write","_len6","_key6","estimateGas","_options$account","_len7","_key7","client","account","values","_ref2","hasArgs","isArray","_ref3","inputs","some","indexed"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/actions/getContract.ts"],"sourcesContent":["import type {\n  Abi,\n  AbiEvent,\n  AbiFunction,\n  AbiParametersToPrimitiveTypes,\n  Address,\n  ExtractAbiEvent,\n  ExtractAbiEventNames,\n  ExtractAbiFunction,\n  ExtractAbiFunctionNames,\n} from 'abitype'\n\nimport type { Account } from '../accounts/types.js'\nimport type { PublicClient } from '../clients/createPublicClient.js'\nimport type { WalletClient } from '../clients/createWalletClient.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { Chain } from '../types/chain.js'\nimport type {\n  AbiEventParametersToPrimitiveTypes,\n  MaybeExtractEventArgsFromAbi,\n} from '../types/contract.js'\nimport type {\n  IsNarrowable,\n  IsNever,\n  IsUndefined,\n  Or,\n  Prettify,\n  UnionOmit,\n} from '../types/utils.js'\n\nimport {\n  type CreateContractEventFilterParameters,\n  type CreateContractEventFilterReturnType,\n  createContractEventFilter,\n} from './public/createContractEventFilter.js'\nimport {\n  type EstimateContractGasParameters,\n  type EstimateContractGasReturnType,\n  estimateContractGas,\n} from './public/estimateContractGas.js'\nimport {\n  type GetContractEventsParameters,\n  type GetContractEventsReturnType,\n  getContractEvents,\n} from './public/getContractEvents.js'\nimport {\n  type ReadContractParameters,\n  type ReadContractReturnType,\n  readContract,\n} from './public/readContract.js'\nimport {\n  type SimulateContractParameters,\n  type SimulateContractReturnType,\n  simulateContract,\n} from './public/simulateContract.js'\nimport {\n  type WatchContractEventParameters,\n  type WatchContractEventReturnType,\n  watchContractEvent,\n} from './public/watchContractEvent.js'\nimport {\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from './wallet/writeContract.js'\n\nexport type GetContractParameters<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TPublicClient extends PublicClient<TTransport, TChain> | unknown = unknown,\n  TWalletClient extends\n    | WalletClient<TTransport, TChain, TAccount>\n    | unknown = unknown,\n  TAddress extends Address = Address,\n> = {\n  /** Contract ABI */\n  abi: TAbi\n  /** Contract address */\n  address: TAddress\n  /**\n   * Public client\n   *\n   * If you pass in a [`publicClient`](https://viem.sh/docs/clients/public.html), the following methods are available:\n   *\n   * - [`createEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html)\n   * - [`estimateGas`](https://viem.sh/docs/contract/estimateContractGas.html)\n   * - [`getEvents`](https://viem.sh/docs/contract/getContractEvents.html)\n   * - [`read`](https://viem.sh/docs/contract/readContract.html)\n   * - [`simulate`](https://viem.sh/docs/contract/simulateContract.html)\n   * - [`watchEvent`](https://viem.sh/docs/contract/watchContractEvent.html)\n   */\n  publicClient?: TPublicClient\n  /**\n   * Wallet client\n   *\n   * If you pass in a [`walletClient`](https://viem.sh/docs/clients/wallet.html), the following methods are available:\n   *\n   * - [`estimateGas`](https://viem.sh/docs/contract/estimateContractGas.html)\n   * - [`write`](https://viem.sh/docs/contract/writeContract.html)\n   */\n  walletClient?: TWalletClient\n}\n\nexport type GetContractReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TPublicClient extends PublicClient | unknown = unknown,\n  TWalletClient extends WalletClient | unknown = unknown,\n  TAddress extends Address = Address,\n  _EventNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiEventNames<TAbi>\n    : string,\n  _ReadFunctionNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiFunctionNames<TAbi, 'pure' | 'view'>\n    : string,\n  _WriteFunctionNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiFunctionNames<TAbi, 'nonpayable' | 'payable'>\n    : string,\n  _Narrowable extends boolean = IsNarrowable<TAbi, Abi>,\n> = Prettify<\n  (TPublicClient extends PublicClient\n    ? (IsNever<_ReadFunctionNames> extends true\n        ? unknown\n        : {\n            /**\n             * Calls a read-only function on a contract, and returns the response.\n             *\n             * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n             *\n             * Internally, `read` uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n             *\n             * @example\n             * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n             * import { mainnet } from 'viem/chains'\n             *\n             * const publicClient = createPublicClient({\n             *   chain: mainnet,\n             *   transport: http(),\n             * })\n             * const contract = getContract({\n             *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n             *   abi: parseAbi([\n             *     'function balanceOf(address owner) view returns (uint256)',\n             *   ]),\n             *   publicClient,\n             * })\n             * const result = await contract.read.balanceOf(['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'])\n             * // 424122n\n             */\n            read: {\n              [FunctionName in _ReadFunctionNames]: GetReadFunction<\n                _Narrowable,\n                TAbi,\n                FunctionName\n              >\n            }\n          }) &\n        (IsNever<_WriteFunctionNames> extends true\n          ? unknown\n          : {\n              /**\n               * Estimates the gas necessary to complete a transaction without submitting it to the network.\n               *\n               * @example\n               * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n               * import { mainnet } from 'viem/chains'\n               *\n               * const publicClient = createPublicClient({\n               *   chain: mainnet,\n               *   transport: http(),\n               * })\n               * const contract = getContract({\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               *   abi: parseAbi(['function mint() public']),\n               *   publicClient,\n               * })\n               * const gas = await contract.estimateGas.mint({\n               *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n               * })\n               */\n              estimateGas: {\n                [FunctionName in _WriteFunctionNames]: GetEstimateFunction<\n                  _Narrowable,\n                  TPublicClient['chain'],\n                  undefined,\n                  TAbi,\n                  FunctionName\n                >\n              }\n              /**\n               * Simulates/validates a contract interaction. This is useful for retrieving return data and revert reasons of contract write functions.\n               *\n               * This function does not require gas to execute and does not change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions.\n               *\n               * Internally, `simulate` uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n               *\n               * @example\n               * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n               * import { mainnet } from 'viem/chains'\n               *\n               * const publicClient = createPublicClient({\n               *   chain: mainnet,\n               *   transport: http(),\n               * })\n               * const contract = getContract({\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               *   abi: parseAbi(['function mint() public']),\n               *   publicClient,\n               * })\n               * const result = await contract.simulate.mint({\n               *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n               * })\n               */\n              simulate: {\n                [FunctionName in _WriteFunctionNames]: GetSimulateFunction<\n                  _Narrowable,\n                  TPublicClient['chain'],\n                  TAbi,\n                  FunctionName\n                >\n              }\n            }) &\n        (IsNever<_EventNames> extends true\n          ? unknown\n          : {\n              /**\n               * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html).\n               *\n               * @example\n               * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n               * import { mainnet } from 'viem/chains'\n               *\n               * const publicClient = createPublicClient({\n               *   chain: mainnet,\n               *   transport: http(),\n               * })\n               * const contract = getContract({\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n               *   publicClient,\n               * })\n               * const filter = await contract.createEventFilter.Transfer()\n               */\n              createEventFilter: {\n                [EventName in _EventNames]: GetEventFilter<\n                  _Narrowable,\n                  TAbi,\n                  EventName\n                >\n              }\n              /**\n               * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html).\n               *\n               * @example\n               * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n               * import { mainnet } from 'viem/chains'\n               *\n               * const publicClient = createPublicClient({\n               *   chain: mainnet,\n               *   transport: http(),\n               * })\n               * const contract = getContract({\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n               *   publicClient,\n               * })\n               * const filter = await contract.createEventFilter.Transfer()\n               */\n              getEvents: {\n                [EventName in _EventNames]: GetEventsFunction<\n                  _Narrowable,\n                  TAbi,\n                  EventName\n                >\n              }\n              /**\n               * Watches and returns emitted contract event logs.\n               *\n               * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).\n               *\n               * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getEvents`](https://viem.sh/docs/actions/public/getEvents.html) instead.\n               *\n               * @example\n               * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n               * import { mainnet } from 'viem/chains'\n               *\n               * const publicClient = createPublicClient({\n               *   chain: mainnet,\n               *   transport: http(),\n               * })\n               * const contract = getContract({\n               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n               *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n               *   publicClient,\n               * })\n               * const filter = await contract.createEventFilter.Transfer()\n               * const unwatch = contract.watchEvent.Transfer(\n               *   { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n               *   { onLogs: (logs) => console.log(logs) },\n               * )\n               */\n              watchEvent: {\n                [EventName in _EventNames]: GetWatchEvent<\n                  _Narrowable,\n                  TAbi,\n                  EventName\n                >\n              }\n            })\n    : unknown) &\n    (TWalletClient extends WalletClient\n      ? IsNever<_WriteFunctionNames> extends true\n        ? unknown\n        : {\n            /**\n             * Estimates the gas necessary to complete a transaction without submitting it to the network.\n             *\n             * @example\n             * import { createWalletClient, getContract, http, parseAbi } from 'viem'\n             * import { mainnet } from 'viem/chains'\n             *\n             * const walletClient = createWalletClient({\n             *   chain: mainnet,\n             *   transport: http(),\n             * })\n             * const contract = getContract({\n             *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n             *   abi: parseAbi(['function mint() public']),\n             *   walletClient,\n             * })\n             * const gas = await contract.estimateGas.mint({\n             *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n             * })\n             */\n            estimateGas: {\n              [FunctionName in _WriteFunctionNames]: GetEstimateFunction<\n                _Narrowable,\n                TWalletClient['chain'],\n                TWalletClient['account'],\n                TAbi,\n                FunctionName\n              >\n            }\n            /**\n             * Executes a write function on a contract.\n             *\n             * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms.html) is needed to be broadcast in order to change the state.\n             *\n             * Internally, `write` uses a [Wallet Client](https://viem.sh/docs/clients/wallet.html) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n             *\n             * __Warning: The `write` internally sends a transaction â€“ it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract.html#usage) before you execute it.__\n             *\n             * @example\n             * import { createWalletClient, getContract, http, parseAbi } from 'viem'\n             * import { mainnet } from 'viem/chains'\n             *\n             * const walletClient = createWalletClient({\n             *   chain: mainnet,\n             *   transport: http(),\n             * })\n             * const contract = getContract({\n             *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n             *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n             *   walletClient,\n             * })\n             * const hash = await contract.write.min([69420], {\n             *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n             * })\n             */\n            write: {\n              [FunctionName in _WriteFunctionNames]: GetWriteFunction<\n                _Narrowable,\n                TWalletClient['chain'],\n                TWalletClient['account'],\n                TAbi,\n                FunctionName\n              >\n            }\n          }\n      : unknown)\n> & { address: TAddress; abi: TAbi }\n\n/**\n * Gets type-safe interface for performing contract-related actions with a specific `abi` and `address`.\n *\n * - Docs https://viem.sh/docs/contract/getContract.html\n *\n * Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properites every time you perform contract actions, e.g. [`readContract`](https://viem.sh/docs/contract/readContract.html), [`writeContract`](https://viem.sh/docs/contract/writeContract.html), [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas.html), etc.\n *\n * @example\n * import { createPublicClient, getContract, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const publicClient = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const contract = getContract({\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi([\n *     'function balanceOf(address owner) view returns (uint256)',\n *     'function ownerOf(uint256 tokenId) view returns (address)',\n *     'function totalSupply() view returns (uint256)',\n *   ]),\n *   publicClient,\n * })\n */\nexport function getContract<\n  TTransport extends Transport,\n  TAddress extends Address,\n  const TAbi extends Abi | readonly unknown[],\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TPublicClient extends PublicClient<TTransport, TChain> | undefined =\n    | PublicClient<TTransport, TChain>\n    | undefined,\n  TWalletClient extends WalletClient<TTransport, TChain, TAccount> | undefined =\n    | WalletClient<TTransport, TChain, TAccount>\n    | undefined,\n>({\n  abi,\n  address,\n  publicClient,\n  walletClient,\n}: GetContractParameters<\n  TTransport,\n  TChain,\n  TAccount,\n  TAbi,\n  TPublicClient,\n  TWalletClient,\n  TAddress\n>): GetContractReturnType<TAbi, TPublicClient, TWalletClient, TAddress> {\n  const hasPublicClient = publicClient !== undefined && publicClient !== null\n  const hasWalletClient = walletClient !== undefined && walletClient !== null\n\n  const contract: {\n    [_ in\n      | 'abi'\n      | 'address'\n      | 'createEventFilter'\n      | 'estimateGas'\n      | 'getEvents'\n      | 'read'\n      | 'simulate'\n      | 'watchEvent'\n      | 'write']?: unknown\n  } = {}\n\n  let hasReadFunction = false\n  let hasWriteFunction = false\n  let hasEvent = false\n  for (const item of abi as Abi) {\n    if (item.type === 'function')\n      if (item.stateMutability === 'view' || item.stateMutability === 'pure')\n        hasReadFunction = true\n      else hasWriteFunction = true\n    else if (item.type === 'event') hasEvent = true\n    // Exit early if all flags are `true`\n    if (hasReadFunction && hasWriteFunction && hasEvent) break\n  }\n\n  if (hasPublicClient) {\n    if (hasReadFunction)\n      contract.read = new Proxy(\n        {},\n        {\n          get(_, functionName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[],\n                options?: UnionOmit<\n                  ReadContractParameters,\n                  'abi' | 'address' | 'functionName' | 'args'\n                >,\n              ]\n            ) => {\n              const { args, options } = getFunctionParameters(parameters)\n              return readContract(publicClient, {\n                abi,\n                address,\n                functionName,\n                args,\n                ...options,\n              } as ReadContractParameters)\n            }\n          },\n        },\n      )\n\n    if (hasWriteFunction)\n      contract.simulate = new Proxy(\n        {},\n        {\n          get(_, functionName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[],\n                options?: UnionOmit<\n                  SimulateContractParameters,\n                  'abi' | 'address' | 'functionName' | 'args'\n                >,\n              ]\n            ) => {\n              const { args, options } = getFunctionParameters(parameters)\n              return simulateContract(publicClient, {\n                abi,\n                address,\n                functionName,\n                args,\n                ...options,\n              } as SimulateContractParameters)\n            }\n          },\n        },\n      )\n\n    if (hasEvent) {\n      contract.createEventFilter = new Proxy(\n        {},\n        {\n          get(_, eventName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[] | object,\n                options?: Omit<\n                  CreateContractEventFilterParameters,\n                  'abi' | 'address' | 'eventName' | 'args'\n                >,\n              ]\n            ) => {\n              const abiEvent = (abi as readonly AbiEvent[]).find(\n                (x: AbiEvent) => x.type === 'event' && x.name === eventName,\n              )\n              const { args, options } = getEventParameters(\n                parameters,\n                abiEvent!,\n              )\n              return createContractEventFilter(publicClient, {\n                abi,\n                address,\n                eventName,\n                args,\n                ...options,\n              } as CreateContractEventFilterParameters)\n            }\n          },\n        },\n      )\n      contract.getEvents = new Proxy(\n        {},\n        {\n          get(_, eventName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[] | object,\n                options?: Omit<\n                  GetContractEventsParameters,\n                  'abi' | 'address' | 'eventName'\n                >,\n              ]\n            ) => {\n              const abiEvent = (abi as readonly AbiEvent[]).find(\n                (x: AbiEvent) => x.type === 'event' && x.name === eventName,\n              )\n              const { args, options } = getEventParameters(\n                parameters,\n                abiEvent!,\n              )\n              return getContractEvents(publicClient, {\n                abi,\n                address,\n                eventName,\n                args,\n                ...options,\n              } as unknown as GetContractEventsParameters)\n            }\n          },\n        },\n      )\n      contract.watchEvent = new Proxy(\n        {},\n        {\n          get(_, eventName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[] | object,\n                options?: Omit<\n                  WatchContractEventParameters,\n                  'abi' | 'address' | 'eventName'\n                >,\n              ]\n            ) => {\n              const abiEvent = (abi as readonly AbiEvent[]).find(\n                (x: AbiEvent) => x.type === 'event' && x.name === eventName,\n              )\n              const { args, options } = getEventParameters(\n                parameters,\n                abiEvent!,\n              )\n              return watchContractEvent(publicClient, {\n                abi,\n                address,\n                eventName,\n                args,\n                ...options,\n              } as unknown as WatchContractEventParameters)\n            }\n          },\n        },\n      )\n    }\n  }\n\n  if (hasWalletClient) {\n    if (hasWriteFunction)\n      contract.write = new Proxy(\n        {},\n        {\n          get(_, functionName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[],\n                options?: UnionOmit<\n                  WriteContractParameters,\n                  'abi' | 'address' | 'functionName' | 'args'\n                >,\n              ]\n            ) => {\n              const { args, options } = getFunctionParameters(parameters)\n              return writeContract(walletClient, {\n                abi,\n                address,\n                functionName,\n                args,\n                ...options,\n              } as unknown as WriteContractParameters<\n                TAbi,\n                typeof functionName,\n                TChain,\n                TAccount\n              >)\n            }\n          },\n        },\n      )\n  }\n\n  if (hasPublicClient || hasWalletClient)\n    if (hasWriteFunction)\n      contract.estimateGas = new Proxy(\n        {},\n        {\n          get(_, functionName: string) {\n            return (\n              ...parameters: [\n                args?: readonly unknown[],\n                options?: UnionOmit<\n                  EstimateContractGasParameters,\n                  'abi' | 'address' | 'functionName' | 'args'\n                >,\n              ]\n            ) => {\n              const { args, options } = getFunctionParameters(parameters)\n              const client = (publicClient ?? walletClient)!\n              return estimateContractGas(client, {\n                abi,\n                address,\n                functionName,\n                args,\n                ...options,\n                account:\n                  (options as EstimateContractGasParameters).account ??\n                  (walletClient as unknown as WalletClient).account,\n              } as any)\n            }\n          },\n        },\n      )\n  contract.address = address\n  contract.abi = abi\n\n  return contract as unknown as GetContractReturnType<\n    TAbi,\n    TPublicClient,\n    TWalletClient,\n    TAddress\n  >\n}\n\n/**\n * @internal exporting for testing only\n */\nexport function getFunctionParameters(\n  values: [args?: readonly unknown[], options?: object],\n) {\n  const hasArgs = values.length && Array.isArray(values[0])\n  const args = hasArgs ? values[0]! : []\n  const options = (hasArgs ? values[1] : values[0]) ?? {}\n  return { args, options }\n}\n\n/**\n * @internal exporting for testing only\n */\nexport function getEventParameters(\n  values: [args?: object | unknown[], options?: object],\n  abiEvent: AbiEvent,\n) {\n  let hasArgs = false\n  // If first item is array, must be `args`\n  if (Array.isArray(values[0])) hasArgs = true\n  // Check if first item is `args` or `options`\n  else if (values.length === 1) {\n    // if event has indexed inputs, must have `args`\n    hasArgs = abiEvent.inputs.some((x) => x.indexed)\n    // If there are two items in array, must have `args`\n  } else if (values.length === 2) {\n    hasArgs = true\n  }\n\n  const args = hasArgs ? values[0]! : undefined\n  const options = (hasArgs ? values[1] : values[0]) ?? {}\n  return { args, options }\n}\n\ntype GetReadFunction<\n  Narrowable extends boolean,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TAbiFunction extends AbiFunction = TAbi extends Abi\n    ? ExtractAbiFunction<TAbi, TFunctionName>\n    : AbiFunction,\n  Args = AbiParametersToPrimitiveTypes<TAbiFunction['inputs']>,\n  Options = Prettify<\n    UnionOmit<\n      ReadContractParameters<TAbi, TFunctionName>,\n      'abi' | 'address' | 'args' | 'functionName'\n    >\n  >,\n> = Narrowable extends true\n  ? (\n      ...parameters: Args extends readonly []\n        ? [options?: Options]\n        : [args: Args, options?: Options]\n    ) => Promise<ReadContractReturnType<TAbi, TFunctionName>>\n  : (\n      ...parameters:\n        | [options?: Options]\n        | [args: readonly unknown[], options?: Options]\n    ) => Promise<ReadContractReturnType>\n\ntype GetEstimateFunction<\n  Narrowable extends boolean,\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TAbiFunction extends AbiFunction = TAbi extends Abi\n    ? ExtractAbiFunction<TAbi, TFunctionName>\n    : AbiFunction,\n  Args = AbiParametersToPrimitiveTypes<TAbiFunction['inputs']>,\n  Options = Prettify<\n    UnionOmit<\n      EstimateContractGasParameters<TAbi, TFunctionName, TChain, TAccount>,\n      'abi' | 'address' | 'args' | 'functionName'\n    >\n  >,\n  // For making `options` parameter required if `TAccount`\n  IsOptionsRequired = IsUndefined<TAccount>,\n> = Narrowable extends true\n  ? (\n      ...parameters: Args extends readonly []\n        ? IsOptionsRequired extends true\n          ? [options: Options]\n          : [options?: Options]\n        : [\n            args: Args,\n            ...parameters: IsOptionsRequired extends true\n              ? [options: Options]\n              : [options?: Options],\n          ]\n    ) => Promise<EstimateContractGasReturnType>\n  : (\n      ...parameters:\n        | (IsOptionsRequired extends true\n            ? [options: Options]\n            : [options?: Options])\n        | [\n            args: readonly unknown[],\n            ...parameters: IsOptionsRequired extends true\n              ? [options: Options]\n              : [options?: Options],\n          ]\n    ) => Promise<EstimateContractGasReturnType>\n\ntype GetSimulateFunction<\n  Narrowable extends boolean,\n  TChain extends Chain | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TAbiFunction extends AbiFunction = TAbi extends Abi\n    ? ExtractAbiFunction<TAbi, TFunctionName>\n    : AbiFunction,\n  Args = AbiParametersToPrimitiveTypes<TAbiFunction['inputs']>,\n> = Narrowable extends true\n  ? <\n      TChainOverride extends Chain | undefined,\n      Options extends Prettify<\n        UnionOmit<\n          SimulateContractParameters<\n            TAbi,\n            TFunctionName,\n            TChain,\n            TChainOverride\n          >,\n          'abi' | 'address' | 'args' | 'functionName'\n        >\n      >,\n    >(\n      ...parameters: Args extends readonly []\n        ? [options?: Options]\n        : [args: Args, options?: Options]\n    ) => Promise<\n      SimulateContractReturnType<TAbi, TFunctionName, TChain, TChainOverride>\n    >\n  : <\n      TChainOverride extends Chain | undefined,\n      Options extends Prettify<\n        UnionOmit<\n          SimulateContractParameters<\n            TAbi,\n            TFunctionName,\n            TChain,\n            TChainOverride\n          >,\n          'abi' | 'address' | 'args' | 'functionName'\n        >\n      >,\n    >(\n      ...parameters:\n        | [options?: Options]\n        | [args: readonly unknown[], options?: Options]\n    ) => Promise<SimulateContractReturnType>\n\ntype GetWriteFunction<\n  Narrowable extends boolean,\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TAbiFunction extends AbiFunction = TAbi extends Abi\n    ? ExtractAbiFunction<TAbi, TFunctionName>\n    : AbiFunction,\n  Args = AbiParametersToPrimitiveTypes<TAbiFunction['inputs']>,\n  // For making `options` parameter required if `TAccount` or `TChain` is undefined\n  IsOptionsRequired = Or<[IsUndefined<TAccount>, IsUndefined<TChain>]>,\n> = Narrowable extends true\n  ? <\n      TChainOverride extends Chain | undefined,\n      Options extends Prettify<\n        UnionOmit<\n          WriteContractParameters<\n            TAbi,\n            TFunctionName,\n            TChain,\n            TAccount,\n            TChainOverride\n          >,\n          'abi' | 'address' | 'args' | 'functionName'\n        >\n      >,\n    >(\n      ...parameters: Args extends readonly []\n        ? IsOptionsRequired extends true\n          ? [options: Options]\n          : [options?: Options]\n        : [\n            args: Args,\n            ...parameters: IsOptionsRequired extends true\n              ? [options: Options]\n              : [options?: Options],\n          ]\n    ) => Promise<WriteContractReturnType>\n  : <\n      TChainOverride extends Chain | undefined,\n      Options extends Prettify<\n        UnionOmit<\n          WriteContractParameters<\n            TAbi,\n            TFunctionName,\n            TChain,\n            TAccount,\n            TChainOverride\n          >,\n          'abi' | 'address' | 'args' | 'functionName'\n        >\n      >,\n      Rest extends unknown[] = IsOptionsRequired extends true\n        ? [options: Options]\n        : [options?: Options],\n    >(\n      ...parameters: Rest | [args: readonly unknown[], ...parameters: Rest]\n    ) => Promise<WriteContractReturnType>\n\ntype GetEventFilter<\n  Narrowable extends boolean,\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n  TAbiEvent extends AbiEvent = TAbi extends Abi\n    ? ExtractAbiEvent<TAbi, TEventName>\n    : AbiEvent,\n  Args = AbiEventParametersToPrimitiveTypes<TAbiEvent['inputs']>,\n  Options = Prettify<\n    Omit<\n      CreateContractEventFilterParameters<TAbi, TEventName>,\n      'abi' | 'address' | 'args' | 'eventName' | 'strict'\n    >\n  >,\n  IndexedInputs = Extract<TAbiEvent['inputs'][number], { indexed: true }>,\n> = Narrowable extends true\n  ? <\n      const TArgs extends\n        | MaybeExtractEventArgsFromAbi<TAbi, TEventName>\n        | undefined,\n      TStrict extends boolean | undefined = undefined,\n    >(\n      ...parameters: IsNever<IndexedInputs> extends true\n        ? [options?: Options & { strict?: TStrict }]\n        : [\n            args: Args | (Args extends TArgs ? Readonly<TArgs> : never),\n            options?: Options & { strict?: TStrict },\n          ]\n    ) => Promise<\n      CreateContractEventFilterReturnType<TAbi, TEventName, TArgs, TStrict>\n    >\n  : <TStrict extends boolean | undefined = undefined>(\n      ...parameters:\n        | [options?: Options & { strict?: TStrict }]\n        | [\n            args: readonly unknown[] | CreateContractFilterOptions,\n            options?: Options & { strict?: TStrict },\n          ]\n    ) => Promise<CreateContractEventFilterReturnType>\n\ntype GetEventsFunction<\n  Narrowable extends boolean,\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n  TAbiEvent extends AbiEvent = TAbi extends Abi\n    ? ExtractAbiEvent<TAbi, TEventName>\n    : AbiEvent,\n  Args = AbiEventParametersToPrimitiveTypes<TAbiEvent['inputs']>,\n  Options = Prettify<\n    Omit<\n      GetContractEventsParameters<TAbi, TEventName>,\n      'abi' | 'address' | 'args' | 'eventName'\n    >\n  >,\n  IndexedInputs = Extract<TAbiEvent['inputs'][number], { indexed: true }>,\n> = Narrowable extends true\n  ? (\n      ...parameters: IsNever<IndexedInputs> extends true\n        ? [options?: Options]\n        : [args?: Args, options?: Options]\n    ) => Promise<GetContractEventsReturnType<TAbi, TEventName>>\n  : (\n      ...parameters:\n        | [options?: Options]\n        | [\n            args?: readonly unknown[] | WatchContractEventOptions,\n            options?: Options,\n          ]\n    ) => Promise<GetContractEventsReturnType<TAbi, TEventName>>\n\ntype GetWatchEvent<\n  Narrowable extends boolean,\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n  TAbiEvent extends AbiEvent = TAbi extends Abi\n    ? ExtractAbiEvent<TAbi, TEventName>\n    : AbiEvent,\n  Args = AbiEventParametersToPrimitiveTypes<TAbiEvent['inputs']>,\n  Options = Prettify<\n    Omit<\n      WatchContractEventParameters<TAbi, TEventName>,\n      'abi' | 'address' | 'args' | 'eventName'\n    >\n  >,\n  IndexedInputs = Extract<TAbiEvent['inputs'][number], { indexed: true }>,\n> = Narrowable extends true\n  ? (\n      ...parameters: IsNever<IndexedInputs> extends true\n        ? [options: Options]\n        : [args: Args, options: Options]\n    ) => WatchContractEventReturnType\n  : (\n      ...parameters:\n        | [options?: Options]\n        | [\n            args: readonly unknown[] | WatchContractEventOptions,\n            options?: Options,\n          ]\n    ) => WatchContractEventReturnType\n\ntype CreateContractFilterOptions =\n  RemoveProperties<CreateContractEventFilterParameters>\ntype WatchContractEventOptions = RemoveProperties<WatchContractEventParameters>\n\ntype RemoveProperties<T extends object> = Prettify<\n  {\n    [key: string]: unknown\n  } & {\n    [_ in keyof T]?: never\n  }\n>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}