{"ast":null,"code":"import { isHex } from '../data/isHex.js';\nimport { hexToNumber } from '../encoding/fromHex.js';\nimport { toHex } from '../encoding/toHex.js';\nexport async function recoverPublicKey(_ref) {\n  let {\n    hash,\n    signature\n  } = _ref;\n  const signatureHex = isHex(signature) ? signature : toHex(signature);\n  const hashHex = isHex(hash) ? hash : toHex(hash);\n  // Derive v = recoveryId + 27 from end of the signature (27 is added when signing the message)\n  // The recoveryId represents the y-coordinate on the secp256k1 elliptic curve and can have a value [0, 1].\n  let v = hexToNumber(`0x${signatureHex.slice(130)}`);\n  if (v === 0 || v === 1) v += 27;\n  const {\n    secp256k1\n  } = await import('@noble/curves/secp256k1');\n  const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);\n  return `0x${publicKey}`;\n}","map":{"version":3,"names":["isHex","hexToNumber","toHex","recoverPublicKey","_ref","hash","signature","signatureHex","hashHex","v","slice","secp256k1","publicKey","Signature","fromCompact","substring","addRecoveryBit"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/signature/recoverPublicKey.ts"],"sourcesContent":["import type { ByteArray, Hex } from '../../types/misc.js'\nimport { isHex } from '../data/isHex.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\nimport { toHex } from '../encoding/toHex.js'\n\nexport type RecoverPublicKeyParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray\n}\nexport type RecoverPublicKeyReturnType = Hex\n\nexport async function recoverPublicKey({\n  hash,\n  signature,\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\n  const signatureHex = isHex(signature) ? signature : toHex(signature)\n  const hashHex = isHex(hash) ? hash : toHex(hash)\n\n  // Derive v = recoveryId + 27 from end of the signature (27 is added when signing the message)\n  // The recoveryId represents the y-coordinate on the secp256k1 elliptic curve and can have a value [0, 1].\n  let v = hexToNumber(`0x${signatureHex.slice(130)}`)\n  if (v === 0 || v === 1) v += 27\n\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\n  const publicKey = secp256k1.Signature.fromCompact(\n    signatureHex.substring(2, 130),\n  )\n    .addRecoveryBit(v - 27)\n    .recoverPublicKey(hashHex.substring(2))\n    .toHex(false)\n  return `0x${publicKey}`\n}\n"],"mappings":"AACA,SAASA,KAAK,QAAQ,kBAAkB;AACxC,SAASC,WAAW,QAAQ,wBAAwB;AACpD,SAASC,KAAK,QAAQ,sBAAsB;AAQ5C,OAAO,eAAeC,gBAAgBA,CAAAC,IAAA,EAGT;EAAA,IAHU;IACrCC,IAAI;IACJC;EAAS,CACkB,GAAAF,IAAA;EAC3B,MAAMG,YAAY,GAAGP,KAAK,CAACM,SAAS,CAAC,GAAGA,SAAS,GAAGJ,KAAK,CAACI,SAAS,CAAC;EACpE,MAAME,OAAO,GAAGR,KAAK,CAACK,IAAI,CAAC,GAAGA,IAAI,GAAGH,KAAK,CAACG,IAAI,CAAC;EAEhD;EACA;EACA,IAAII,CAAC,GAAGR,WAAW,CAAC,KAAKM,YAAY,CAACG,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC;EACnD,IAAID,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC,EAAEA,CAAC,IAAI,EAAE;EAE/B,MAAM;IAAEE;EAAS,CAAE,GAAG,MAAM,MAAM,CAAC,yBAAyB,CAAC;EAC7D,MAAMC,SAAS,GAAGD,SAAS,CAACE,SAAS,CAACC,WAAW,CAC/CP,YAAY,CAACQ,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,CAC/B,CACEC,cAAc,CAACP,CAAC,GAAG,EAAE,CAAC,CACtBN,gBAAgB,CAACK,OAAO,CAACO,SAAS,CAAC,CAAC,CAAC,CAAC,CACtCb,KAAK,CAAC,KAAK,CAAC;EACf,OAAO,KAAKU,SAAS,EAAE;AACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}