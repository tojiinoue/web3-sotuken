{"ast":null,"code":"import { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError } from '../../errors/transaction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withRetry } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction } from './getTransaction.js';\nimport { getTransactionReceipt } from './getTransactionReceipt.js';\nimport { watchBlockNumber } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error.\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html\n * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, _ref) {\n  let {\n    confirmations = 1,\n    hash,\n    onReplaced,\n    pollingInterval = client.pollingInterval,\n    timeout\n  } = _ref;\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  return new Promise((resolve, reject) => {\n    if (timeout) setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({\n      hash\n    })), timeout);\n    const _unobserve = observe(observerId, {\n      onReplaced,\n      resolve,\n      reject\n    }, emit => {\n      const _unwatch = watchBlockNumber(client, {\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          if (retrying) return;\n          let blockNumber = blockNumber_;\n          const done = fn => {\n            _unwatch();\n            fn();\n            _unobserve();\n          };\n          try {\n            // If we already have a valid receipt, let's check if we have enough\n            // confirmations. If we do, then we can resolve.\n            if (receipt) {\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              done(() => emit.resolve(receipt));\n              return;\n            }\n            // Get the transaction to check if it's been replaced.\n            // We need to retry as some RPC Providers may be slow to sync\n            // up mined transactions.\n            if (!transaction) {\n              retrying = true;\n              await withRetry(async () => {\n                transaction = await getTransaction(client, {\n                  hash\n                });\n                if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n              }, {\n                // exponential backoff\n                delay: _ref2 => {\n                  let {\n                    count\n                  } = _ref2;\n                  return ~~(1 << count) * 200;\n                },\n                retryCount: 6\n              });\n              retrying = false;\n            }\n            // Get the receipt to check if it's been processed.\n            receipt = await getTransactionReceipt(client, {\n              hash\n            });\n            // Check if we have enough confirmations. If not, continue polling.\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n          } catch (err) {\n            // If the receipt is not found, the transaction will be pending.\n            // We need to check if it has potentially been replaced.\n            if (transaction && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {\n              try {\n                replacedTransaction = transaction;\n                // Let's retrieve the transactions from the current block.\n                const block = await getBlock(client, {\n                  blockNumber,\n                  includeTransactions: true\n                });\n                const replacementTransaction = block.transactions.find(_ref3 => {\n                  let {\n                    from,\n                    nonce\n                  } = _ref3;\n                  return from === replacedTransaction.from && nonce === replacedTransaction.nonce;\n                });\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return;\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getTransactionReceipt(client, {\n                  hash: replacementTransaction.hash\n                });\n                // Check if we have enough confirmations. If not, continue polling.\n                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n                let reason = 'replaced';\n                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {\n                  reason = 'repriced';\n                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                  reason = 'cancelled';\n                }\n                done(() => {\n                  var _emit$onReplaced;\n                  (_emit$onReplaced = emit.onReplaced) === null || _emit$onReplaced === void 0 || _emit$onReplaced.call(emit, {\n                    reason,\n                    replacedTransaction: replacedTransaction,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt\n                  });\n                  emit.resolve(receipt);\n                });\n              } catch (err_) {\n                done(() => emit.reject(err_));\n              }\n            } else {\n              done(() => emit.reject(err));\n            }\n          }\n        }\n      });\n    });\n  });\n}","map":{"version":3,"names":["TransactionNotFoundError","TransactionReceiptNotFoundError","WaitForTransactionReceiptTimeoutError","observe","withRetry","stringify","getBlock","getTransaction","getTransactionReceipt","watchBlockNumber","waitForTransactionReceipt","client","_ref","confirmations","hash","onReplaced","pollingInterval","timeout","observerId","uid","transaction","replacedTransaction","receipt","retrying","Promise","resolve","reject","setTimeout","_unobserve","emit","_unwatch","emitMissed","emitOnBegin","poll","onBlockNumber","blockNumber_","blockNumber","done","fn","delay","_ref2","count","retryCount","err","block","includeTransactions","replacementTransaction","transactions","find","_ref3","from","nonce","reason","to","value","_emit$onReplaced","call","transactionReceipt","err_"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/actions/public/waitForTransactionReceipt.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n} from '../../errors/transaction.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { observe } from '../../utils/observe.js'\nimport { withRetry } from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { getBlock } from './getBlock.js'\nimport {\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport { watchBlockNumber } from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  TChain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<TChain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  TChain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<TChain>\n\nexport type WaitForTransactionReceiptParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: (response: ReplacementReturnType<TChain>) => void\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number\n  /** Optional timeout (in milliseconds) to wait before stopping polling. */\n  timeout?: number\n}\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error.\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html\n * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  TChain extends Chain | undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    confirmations = 1,\n    hash,\n    onReplaced,\n    pollingInterval = client.pollingInterval,\n    timeout,\n  }: WaitForTransactionReceiptParameters<TChain>,\n): Promise<WaitForTransactionReceiptReturnType<TChain>> {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  let transaction: GetTransactionReturnType<TChain> | undefined\n  let replacedTransaction: GetTransactionReturnType<TChain> | undefined\n  let receipt: GetTransactionReceiptReturnType<TChain>\n  let retrying = false\n\n  return new Promise((resolve, reject) => {\n    if (timeout)\n      setTimeout(\n        () => reject(new WaitForTransactionReceiptTimeoutError({ hash })),\n        timeout,\n      )\n\n    const _unobserve = observe(\n      observerId,\n      { onReplaced, resolve, reject },\n      (emit) => {\n        const _unwatch = watchBlockNumber(client, {\n          emitMissed: true,\n          emitOnBegin: true,\n          poll: true,\n          pollingInterval,\n          async onBlockNumber(blockNumber_) {\n            if (retrying) return\n\n            let blockNumber = blockNumber_\n\n            const done = (fn: () => void) => {\n              _unwatch()\n              fn()\n              _unobserve()\n            }\n\n            try {\n              // If we already have a valid receipt, let's check if we have enough\n              // confirmations. If we do, then we can resolve.\n              if (receipt) {\n                if (\n                  confirmations > 1 &&\n                  (!receipt.blockNumber ||\n                    blockNumber - receipt.blockNumber + 1n < confirmations)\n                )\n                  return\n\n                done(() => emit.resolve(receipt))\n                return\n              }\n\n              // Get the transaction to check if it's been replaced.\n              // We need to retry as some RPC Providers may be slow to sync\n              // up mined transactions.\n              if (!transaction) {\n                retrying = true\n                await withRetry(\n                  async () => {\n                    transaction = await getTransaction(client, { hash })\n                    if (transaction.blockNumber)\n                      blockNumber = transaction.blockNumber\n                  },\n                  {\n                    // exponential backoff\n                    delay: ({ count }) => ~~(1 << count) * 200,\n                    retryCount: 6,\n                  },\n                )\n                retrying = false\n              }\n\n              // Get the receipt to check if it's been processed.\n              receipt = await getTransactionReceipt(client, { hash })\n\n              // Check if we have enough confirmations. If not, continue polling.\n              if (\n                confirmations > 1 &&\n                (!receipt.blockNumber ||\n                  blockNumber - receipt.blockNumber + 1n < confirmations)\n              )\n                return\n\n              done(() => emit.resolve(receipt))\n            } catch (err) {\n              // If the receipt is not found, the transaction will be pending.\n              // We need to check if it has potentially been replaced.\n              if (\n                transaction &&\n                (err instanceof TransactionNotFoundError ||\n                  err instanceof TransactionReceiptNotFoundError)\n              ) {\n                try {\n                  replacedTransaction = transaction\n\n                  // Let's retrieve the transactions from the current block.\n                  const block = await getBlock(client, {\n                    blockNumber,\n                    includeTransactions: true,\n                  })\n\n                  const replacementTransaction = (\n                    block.transactions as Transaction[]\n                  ).find(\n                    ({ from, nonce }) =>\n                      from === replacedTransaction!.from &&\n                      nonce === replacedTransaction!.nonce,\n                  )\n\n                  // If we couldn't find a replacement transaction, continue polling.\n                  if (!replacementTransaction) return\n\n                  // If we found a replacement transaction, return it's receipt.\n                  receipt = await getTransactionReceipt(client, {\n                    hash: replacementTransaction.hash,\n                  })\n\n                  // Check if we have enough confirmations. If not, continue polling.\n                  if (\n                    confirmations > 1 &&\n                    (!receipt.blockNumber ||\n                      blockNumber - receipt.blockNumber + 1n < confirmations)\n                  )\n                    return\n\n                  let reason: ReplacementReason = 'replaced'\n                  if (\n                    replacementTransaction.to === replacedTransaction.to &&\n                    replacementTransaction.value === replacedTransaction.value\n                  ) {\n                    reason = 'repriced'\n                  } else if (\n                    replacementTransaction.from === replacementTransaction.to &&\n                    replacementTransaction.value === 0n\n                  ) {\n                    reason = 'cancelled'\n                  }\n\n                  done(() => {\n                    emit.onReplaced?.({\n                      reason,\n                      replacedTransaction: replacedTransaction!,\n                      transaction: replacementTransaction,\n                      transactionReceipt: receipt,\n                    })\n                    emit.resolve(receipt)\n                  })\n                } catch (err_) {\n                  done(() => emit.reject(err_))\n                }\n              } else {\n                done(() => emit.reject(err))\n              }\n            }\n          },\n        })\n      },\n    )\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}