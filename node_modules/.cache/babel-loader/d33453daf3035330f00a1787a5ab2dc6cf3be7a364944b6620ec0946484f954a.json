{"ast":null,"code":"import { DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { formatLog } from '../../utils/formatters/log.js';\n/**\n * Returns a list of event logs since the filter was created.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html\n * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n *\n * `getFilterLogs` is only compatible with **event filters**.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterLogsParameters}\n * @returns A list of event logs. {@link GetFilterLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterLogs(client, { filter })\n */\nexport async function getFilterLogs(_client, _ref) {\n  var _filter$strict;\n  let {\n    filter\n  } = _ref;\n  const strict = (_filter$strict = filter.strict) !== null && _filter$strict !== void 0 ? _filter$strict : false;\n  const logs = await filter.request({\n    method: 'eth_getFilterLogs',\n    params: [filter.id]\n  });\n  return logs.map(log => {\n    try {\n      const {\n        eventName,\n        args\n      } = 'abi' in filter && filter.abi ? decodeEventLog({\n        abi: filter.abi,\n        data: log.data,\n        topics: log.topics,\n        strict\n      }) : {\n        eventName: undefined,\n        args: undefined\n      };\n      return formatLog(log, {\n        args,\n        eventName\n      });\n    } catch (err) {\n      let eventName;\n      let isUnnamed;\n      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n        var _err$abiItem$inputs;\n        // If strict mode is on, and log data/topics do not match event definition, skip.\n        if ('strict' in filter && filter.strict) return;\n        eventName = err.abiItem.name;\n        isUnnamed = (_err$abiItem$inputs = err.abiItem.inputs) === null || _err$abiItem$inputs === void 0 ? void 0 : _err$abiItem$inputs.some(x => !('name' in x && x.name));\n      }\n      // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n      return formatLog(log, {\n        args: isUnnamed ? [] : {},\n        eventName\n      });\n    }\n  }).filter(Boolean);\n}","map":{"version":3,"names":["DecodeLogDataMismatch","DecodeLogTopicsMismatch","decodeEventLog","formatLog","getFilterLogs","_client","_ref","_filter$strict","filter","strict","logs","request","method","params","id","map","log","eventName","args","abi","data","topics","undefined","err","isUnnamed","_err$abiItem$inputs","abiItem","name","inputs","some","x","Boolean"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/actions/public/getFilterLogs.ts"],"sourcesContent":["import type { Abi, AbiEvent, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport { formatLog } from '../../utils/formatters/log.js'\n\nexport type GetFilterLogsParameters<\n  TAbi extends Abi | readonly unknown[] | undefined = undefined,\n  TEventName extends string | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  filter: Filter<'event', TAbi, TEventName, any, TStrict, TFromBlock, TToBlock>\n}\nexport type GetFilterLogsReturnType<\n  TAbi extends Abi | readonly unknown[] | undefined = undefined,\n  TEventName extends string | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _AbiEvent extends AbiEvent | undefined = TAbi extends Abi\n    ? TEventName extends string\n      ? ExtractAbiEvent<TAbi, TEventName>\n      : undefined\n    : undefined,\n  _Pending extends boolean =\n    | (TFromBlock extends 'pending' ? true : false)\n    | (TToBlock extends 'pending' ? true : false),\n> = Log<bigint, number, _Pending, _AbiEvent, TStrict, TAbi, TEventName>[]\n\n/**\n * Returns a list of event logs since the filter was created.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html\n * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n *\n * `getFilterLogs` is only compatible with **event filters**.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterLogsParameters}\n * @returns A list of event logs. {@link GetFilterLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterLogs(client, { filter })\n */\nexport async function getFilterLogs<\n  TChain extends Chain | undefined,\n  const TAbi extends Abi | readonly unknown[] | undefined,\n  TEventName extends string | undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  _client: Client<Transport, TChain>,\n  {\n    filter,\n  }: GetFilterLogsParameters<TAbi, TEventName, TStrict, TFromBlock, TToBlock>,\n): Promise<\n  GetFilterLogsReturnType<TAbi, TEventName, TStrict, TFromBlock, TToBlock>\n> {\n  const strict = filter.strict ?? false\n\n  const logs = await filter.request({\n    method: 'eth_getFilterLogs',\n    params: [filter.id],\n  })\n  return logs\n    .map((log) => {\n      try {\n        const { eventName, args } =\n          'abi' in filter && filter.abi\n            ? decodeEventLog({\n                abi: filter.abi,\n                data: log.data,\n                topics: log.topics as any,\n                strict,\n              })\n            : { eventName: undefined, args: undefined }\n        return formatLog(log, { args, eventName })\n      } catch (err) {\n        let eventName\n        let isUnnamed\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if ('strict' in filter && filter.strict) return\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return formatLog(log, { args: isUnnamed ? [] : {}, eventName })\n      }\n    })\n    .filter(Boolean) as unknown as GetFilterLogsReturnType<\n    TAbi,\n    TEventName,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >\n}\n"],"mappings":"AAIA,SACEA,qBAAqB,EACrBC,uBAAuB,QAClB,qBAAqB;AAK5B,SAASC,cAAc,QAAQ,mCAAmC;AAClE,SAASC,SAAS,QAAQ,+BAA+B;AA2BzD;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAO,eAAeC,aAAaA,CAQjCC,OAAkC,EAAAC,IAAA,EAGyC;EAAA,IAAAC,cAAA;EAAA,IAF3E;IACEC;EAAM,CACmE,GAAAF,IAAA;EAI3E,MAAMG,MAAM,IAAAF,cAAA,GAAGC,MAAM,CAACC,MAAM,cAAAF,cAAA,cAAAA,cAAA,GAAI,KAAK;EAErC,MAAMG,IAAI,GAAG,MAAMF,MAAM,CAACG,OAAO,CAAC;IAChCC,MAAM,EAAE,mBAAmB;IAC3BC,MAAM,EAAE,CAACL,MAAM,CAACM,EAAE;GACnB,CAAC;EACF,OAAOJ,IAAI,CACRK,GAAG,CAAEC,GAAG,IAAI;IACX,IAAI;MACF,MAAM;QAAEC,SAAS;QAAEC;MAAI,CAAE,GACvB,KAAK,IAAIV,MAAM,IAAIA,MAAM,CAACW,GAAG,GACzBjB,cAAc,CAAC;QACbiB,GAAG,EAAEX,MAAM,CAACW,GAAG;QACfC,IAAI,EAAEJ,GAAG,CAACI,IAAI;QACdC,MAAM,EAAEL,GAAG,CAACK,MAAa;QACzBZ;OACD,CAAC,GACF;QAAEQ,SAAS,EAAEK,SAAS;QAAEJ,IAAI,EAAEI;MAAS,CAAE;MAC/C,OAAOnB,SAAS,CAACa,GAAG,EAAE;QAAEE,IAAI;QAAED;MAAS,CAAE,CAAC;KAC3C,CAAC,OAAOM,GAAG,EAAE;MACZ,IAAIN,SAAS;MACb,IAAIO,SAAS;MACb,IACED,GAAG,YAAYvB,qBAAqB,IACpCuB,GAAG,YAAYtB,uBAAuB,EACtC;QAAA,IAAAwB,mBAAA;QACA;QACA,IAAI,QAAQ,IAAIjB,MAAM,IAAIA,MAAM,CAACC,MAAM,EAAE;QACzCQ,SAAS,GAAGM,GAAG,CAACG,OAAO,CAACC,IAAI;QAC5BH,SAAS,IAAAC,mBAAA,GAAGF,GAAG,CAACG,OAAO,CAACE,MAAM,cAAAH,mBAAA,uBAAlBA,mBAAA,CAAoBI,IAAI,CAAEC,CAAC,IAAK,EAAE,MAAM,IAAIA,CAAC,IAAIA,CAAC,CAACH,IAAI,CAAC,CAAC;;MAGvE;MACA,OAAOxB,SAAS,CAACa,GAAG,EAAE;QAAEE,IAAI,EAAEM,SAAS,GAAG,EAAE,GAAG,EAAE;QAAEP;MAAS,CAAE,CAAC;;EAEnE,CAAC,CAAC,CACDT,MAAM,CAACuB,OAAO,CAMhB;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}