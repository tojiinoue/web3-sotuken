{"ast":null,"code":"/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleAttr} RuleAttr\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Schema} Schema\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').PropertyValue} PropertyValue\n */\n\nimport { stringify as commas } from 'comma-separated-tokens';\nimport { hasProperty } from 'hast-util-has-property';\nimport { find } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport { zwitch } from 'zwitch';\n\n/** @type {(query: RuleAttr, element: Element, info: Info) => boolean} */\nconst handle = zwitch('operator', {\n  unknown: unknownOperator,\n  // @ts-expect-error: hush.\n  invalid: exists,\n  handlers: {\n    '=': exact,\n    '~=': spaceSeparatedList,\n    '|=': exactOrPrefix,\n    '^=': begins,\n    '$=': ends,\n    '*=': contains\n  }\n});\n\n/**\n * @param {Rule} query\n * @param {Element} element\n * @param {Schema} schema\n * @returns {boolean}\n */\nexport function attribute(query, element, schema) {\n  const attrs = query.attrs;\n  let index = -1;\n  while (++index < attrs.length) {\n    if (!handle(attrs[index], element, find(schema, attrs[index].name))) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check whether an attribute exists.\n *\n * `[attr]`\n *\n * @param {RuleAttr} _\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exists(_, element, info) {\n  return hasProperty(element, info.property);\n}\n\n/**\n * Check whether an attribute has an exact value.\n *\n * `[attr=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exact(query, element, info) {\n  return Boolean(hasProperty(element, info.property) && element.properties && normalizeValue(element.properties[info.property], info) === query.value);\n}\n\n/**\n * Check whether an attribute, interpreted as a space-separated list, contains\n * a value.\n *\n * `[attr~=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction spaceSeparatedList(query, element, info) {\n  const value = element.properties && element.properties[info.property];\n  return (\n    // If this is a space-separated list, and the query is contained in it, return\n    // true.\n    !info.commaSeparated && value && typeof value === 'object' && query.value && value.includes(query.value) ||\n    // For all other values (including comma-separated lists), return whether this\n    // is an exact match.\n    hasProperty(element, info.property) && normalizeValue(value, info) === query.value\n  );\n}\n\n/**\n * Check whether an attribute has a substring as either the exact value or a\n * prefix.\n *\n * `[attr|=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exactOrPrefix(query, element, info) {\n  const value = normalizeValue(element.properties && element.properties[info.property], info);\n  return Boolean(hasProperty(element, info.property) && query.value && (value === query.value || value.slice(0, query.value.length) === query.value && value.charAt(query.value.length) === '-'));\n}\n\n/**\n * Check whether an attribute has a substring as its start.\n *\n * `[attr^=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction begins(query, element, info) {\n  return Boolean(hasProperty(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).slice(0, query.value.length) === query.value);\n}\n\n/**\n * Check whether an attribute has a substring as its end.\n *\n * `[attr$=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction ends(query, element, info) {\n  return Boolean(hasProperty(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).slice(-query.value.length) === query.value);\n}\n\n/**\n * Check whether an attribute contains a substring.\n *\n * `[attr*=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction contains(query, element, info) {\n  return Boolean(hasProperty(element, info.property) && element.properties && query.value && normalizeValue(element.properties[info.property], info).includes(query.value));\n}\n\n// Shouldn’t be called, Parser throws an error instead.\n/**\n * @param {unknown} query\n * @returns {never}\n */\n/* c8 ignore next 4 */\nfunction unknownOperator(query) {\n  // @ts-expect-error: `operator` guaranteed.\n  throw new Error('Unknown operator `' + query.operator + '`');\n}\n\n/**\n * Stringify a hast value back to its HTML form.\n *\n * @param {PropertyValue} value\n * @param {Info} info\n * @returns {string}\n */\nfunction normalizeValue(value, info) {\n  if (typeof value === 'boolean') {\n    return info.attribute;\n  }\n  if (Array.isArray(value)) {\n    return (info.commaSeparated ? commas : spaces)(value);\n  }\n  return String(value);\n}","map":{"version":3,"names":["stringify","commas","hasProperty","find","spaces","zwitch","handle","unknown","unknownOperator","invalid","exists","handlers","exact","spaceSeparatedList","exactOrPrefix","begins","ends","contains","attribute","query","element","schema","attrs","index","length","name","_","info","property","Boolean","properties","normalizeValue","value","commaSeparated","includes","slice","charAt","Error","operator","Array","isArray","String"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/hast-util-select/lib/attribute.js"],"sourcesContent":["/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleAttr} RuleAttr\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Schema} Schema\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').PropertyValue} PropertyValue\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {hasProperty} from 'hast-util-has-property'\nimport {find} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {zwitch} from 'zwitch'\n\n/** @type {(query: RuleAttr, element: Element, info: Info) => boolean} */\nconst handle = zwitch('operator', {\n  unknown: unknownOperator,\n  // @ts-expect-error: hush.\n  invalid: exists,\n  handlers: {\n    '=': exact,\n    '~=': spaceSeparatedList,\n    '|=': exactOrPrefix,\n    '^=': begins,\n    '$=': ends,\n    '*=': contains\n  }\n})\n\n/**\n * @param {Rule} query\n * @param {Element} element\n * @param {Schema} schema\n * @returns {boolean}\n */\nexport function attribute(query, element, schema) {\n  const attrs = query.attrs\n  let index = -1\n\n  while (++index < attrs.length) {\n    if (!handle(attrs[index], element, find(schema, attrs[index].name))) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Check whether an attribute exists.\n *\n * `[attr]`\n *\n * @param {RuleAttr} _\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exists(_, element, info) {\n  return hasProperty(element, info.property)\n}\n\n/**\n * Check whether an attribute has an exact value.\n *\n * `[attr=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exact(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      normalizeValue(element.properties[info.property], info) === query.value\n  )\n}\n\n/**\n * Check whether an attribute, interpreted as a space-separated list, contains\n * a value.\n *\n * `[attr~=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction spaceSeparatedList(query, element, info) {\n  const value = element.properties && element.properties[info.property]\n\n  return (\n    // If this is a space-separated list, and the query is contained in it, return\n    // true.\n    (!info.commaSeparated &&\n      value &&\n      typeof value === 'object' &&\n      query.value &&\n      value.includes(query.value)) ||\n    // For all other values (including comma-separated lists), return whether this\n    // is an exact match.\n    (hasProperty(element, info.property) &&\n      normalizeValue(value, info) === query.value)\n  )\n}\n\n/**\n * Check whether an attribute has a substring as either the exact value or a\n * prefix.\n *\n * `[attr|=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exactOrPrefix(query, element, info) {\n  const value = normalizeValue(\n    element.properties && element.properties[info.property],\n    info\n  )\n\n  return Boolean(\n    hasProperty(element, info.property) &&\n      query.value &&\n      (value === query.value ||\n        (value.slice(0, query.value.length) === query.value &&\n          value.charAt(query.value.length) === '-'))\n  )\n}\n\n/**\n * Check whether an attribute has a substring as its start.\n *\n * `[attr^=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction begins(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).slice(\n        0,\n        query.value.length\n      ) === query.value\n  )\n}\n\n/**\n * Check whether an attribute has a substring as its end.\n *\n * `[attr$=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction ends(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).slice(\n        -query.value.length\n      ) === query.value\n  )\n}\n\n/**\n * Check whether an attribute contains a substring.\n *\n * `[attr*=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction contains(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).includes(\n        query.value\n      )\n  )\n}\n\n// Shouldn’t be called, Parser throws an error instead.\n/**\n * @param {unknown} query\n * @returns {never}\n */\n/* c8 ignore next 4 */\nfunction unknownOperator(query) {\n  // @ts-expect-error: `operator` guaranteed.\n  throw new Error('Unknown operator `' + query.operator + '`')\n}\n\n/**\n * Stringify a hast value back to its HTML form.\n *\n * @param {PropertyValue} value\n * @param {Info} info\n * @returns {string}\n */\nfunction normalizeValue(value, info) {\n  if (typeof value === 'boolean') {\n    return info.attribute\n  }\n\n  if (Array.isArray(value)) {\n    return (info.commaSeparated ? commas : spaces)(value)\n  }\n\n  return String(value)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}