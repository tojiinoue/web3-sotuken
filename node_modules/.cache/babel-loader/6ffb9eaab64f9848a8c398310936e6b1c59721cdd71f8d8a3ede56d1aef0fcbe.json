{"ast":null,"code":"import { InvalidHexBooleanError, SizeOverflowError } from '../../errors/encoding.js';\nimport { size as size_ } from '../data/size.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBytes } from './toBytes.js';\nexport function assertSize(hexOrBytes, _ref) {\n  let {\n    size\n  } = _ref;\n  if (size_(hexOrBytes) > size) throw new SizeOverflowError({\n    givenSize: size_(hexOrBytes),\n    maxSize: size\n  });\n}\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html\n * - Example: https://viem.sh/docs/utilities/fromHex.html#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex(hex, toOrOpts) {\n  const opts = typeof toOrOpts === 'string' ? {\n    to: toOrOpts\n  } : toOrOpts;\n  const to = opts.to;\n  if (to === 'number') return hexToNumber(hex, opts);\n  if (to === 'bigint') return hexToBigInt(hex, opts);\n  if (to === 'string') return hexToString(hex, opts);\n  if (to === 'boolean') return hexToBool(hex, opts);\n  return hexToBytes(hex, opts);\n}\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed\n  } = opts;\n  if (opts.size) assertSize(hex, {\n    size: opts.size\n  });\n  const value = BigInt(hex);\n  if (!signed) return value;\n  const size = (hex.length - 2) / 2;\n  const max = (1n << BigInt(size) * 8n - 1n) - 1n;\n  if (value <= max) return value;\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;\n}\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let hex = hex_;\n  if (opts.size) {\n    assertSize(hex, {\n      size: opts.size\n    });\n    hex = trim(hex);\n  }\n  if (trim(hex) === '0x00') return false;\n  if (trim(hex) === '0x01') return true;\n  throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Number(hexToBigInt(hex, opts));\n}\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let bytes = hexToBytes(hex);\n  if (opts.size) {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = trim(bytes, {\n      dir: 'right'\n    });\n  }\n  return new TextDecoder().decode(bytes);\n}","map":{"version":3,"names":["InvalidHexBooleanError","SizeOverflowError","size","size_","trim","hexToBytes","assertSize","hexOrBytes","_ref","givenSize","maxSize","fromHex","hex","toOrOpts","opts","to","hexToNumber","hexToBigInt","hexToString","hexToBool","arguments","length","undefined","signed","value","BigInt","max","padStart","hex_","Number","bytes","dir","TextDecoder","decode"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/encoding/fromHex.ts"],"sourcesContent":["import {\n  InvalidHexBooleanError,\n  SizeOverflowError,\n} from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { size as size_ } from '../data/size.js'\nimport { trim } from '../data/trim.js'\n\nimport { hexToBytes } from './toBytes.js'\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | TTo\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number\n      /** Type to convert to. */\n      to: TTo\n    }\n\nexport type FromHexReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'bigint'\n  ? bigint\n  : TTo extends 'number'\n  ? number\n  : TTo extends 'bytes'\n  ? ByteArray\n  : TTo extends 'boolean'\n  ? boolean\n  : never\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html\n * - Example: https://viem.sh/docs/utilities/fromHex.html#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<TTo>): FromHexReturnType<TTo> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<TTo>\n  return hexToBytes(hex, opts) as FromHexReturnType<TTo>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}