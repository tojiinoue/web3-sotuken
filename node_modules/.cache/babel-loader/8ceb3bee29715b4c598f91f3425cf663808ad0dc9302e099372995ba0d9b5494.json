{"ast":null,"code":"import { IntegerOutOfRangeError } from '../../errors/encoding.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nconst hexes = /*#__PURE__*/Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html\n * - Example: https://viem.sh/docs/utilities/toHex.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToHex(value, opts);\n  if (typeof value === 'string') {\n    return stringToHex(value, opts);\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts);\n  return bytesToHex(value, opts);\n}\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const hex = `0x${Number(value)}`;\n  if (typeof opts.size === 'number') {\n    assertSize(hex, {\n      size: opts.size\n    });\n    return pad(hex, {\n      size: opts.size\n    });\n  }\n  return hex;\n}\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let hexString = '';\n  for (let i = 0; i < value.length; i++) {\n    hexString += hexes[value[i]];\n  }\n  const hex = `0x${hexString}`;\n  if (typeof opts.size === 'number') {\n    assertSize(hex, {\n      size: opts.size\n    });\n    return pad(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return hex;\n}\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(value_) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signed,\n    size\n  } = opts;\n  const value = BigInt(value_);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value > maxValue || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : '';\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`\n    });\n  }\n  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;\n  if (size) return pad(hex, {\n    size\n  });\n  return hex;\n}\nconst encoder = /*#__PURE__*/new TextEncoder();\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const value = encoder.encode(value_);\n  return bytesToHex(value, opts);\n}","map":{"version":3,"names":["IntegerOutOfRangeError","pad","assertSize","hexes","Array","from","length","_v","i","toString","padStart","toHex","value","opts","arguments","undefined","numberToHex","stringToHex","boolToHex","bytesToHex","hex","Number","size","hexString","dir","value_","signed","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","max","min","encoder","TextEncoder","encode"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/encoding/toHex.ts"],"sourcesContent":["import { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { pad } from '../data/pad.js'\n\nimport { assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html\n * - Example: https://viem.sh/docs/utilities/toHex.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let hexString = ''\n  for (let i = 0; i < value.length; i++) {\n    hexString += hexes[value[i]]\n  }\n\n  const hex: Hex = `0x${hexString}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: never\n      /** The size (in bytes) of the output hex value. */\n      size?: number\n    }\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}