{"ast":null,"code":"import { concat } from '../data/concat.js';\nimport { isBytes } from '../data/isBytes.js';\nimport { pad } from '../data/pad.js';\nimport { slice } from '../data/slice.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toRlp } from '../encoding/toRlp.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { getAddress } from './getAddress.js';\nexport function getContractAddress(opts) {\n  if (opts.opcode === 'CREATE2') return getCreate2Address(opts);\n  return getCreateAddress(opts);\n}\nexport function getCreateAddress(opts) {\n  const from = toBytes(getAddress(opts.from));\n  let nonce = toBytes(opts.nonce);\n  if (nonce[0] === 0) nonce = new Uint8Array([]);\n  return getAddress(`0x${keccak256(toRlp([from, nonce], 'bytes')).slice(26)}`);\n}\nexport function getCreate2Address(opts) {\n  const from = toBytes(getAddress(opts.from));\n  const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt), {\n    size: 32\n  });\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in opts) {\n      if (isBytes(opts.bytecodeHash)) return opts.bytecodeHash;\n      return toBytes(opts.bytecodeHash);\n    }\n    return keccak256(opts.bytecode, 'bytes');\n  })();\n  return getAddress(slice(keccak256(concat([toBytes('0xff'), from, salt, bytecodeHash])), 12));\n}","map":{"version":3,"names":["concat","isBytes","pad","slice","toBytes","toRlp","keccak256","getAddress","getContractAddress","opts","opcode","getCreate2Address","getCreateAddress","from","nonce","Uint8Array","salt","size","bytecodeHash","bytecode"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/utils/address/getContractAddress.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { concat } from '../data/concat.js'\nimport { isBytes } from '../data/isBytes.js'\nimport { pad } from '../data/pad.js'\nimport { slice } from '../data/slice.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { toRlp } from '../encoding/toRlp.js'\nimport { keccak256 } from '../hash/keccak256.js'\n\nimport { getAddress } from './getAddress.js'\n\nexport type GetCreateAddressOptions = {\n  from: Address\n  nonce: bigint\n}\n\nexport type GetCreate2AddressOptions =\n  | {\n      bytecode: ByteArray | Hex\n      from: Address\n      salt: ByteArray | Hex\n    }\n  | {\n      bytecodeHash: ByteArray | Hex\n      from: Address\n      salt: ByteArray | Hex\n    }\n\nexport type GetContractAddressOptions =\n  | ({\n      opcode?: 'CREATE'\n    } & GetCreateAddressOptions)\n  | ({ opcode: 'CREATE2' } & GetCreate2AddressOptions)\n\nexport function getContractAddress(opts: GetContractAddressOptions) {\n  if (opts.opcode === 'CREATE2') return getCreate2Address(opts)\n  return getCreateAddress(opts)\n}\n\nexport function getCreateAddress(opts: GetCreateAddressOptions) {\n  const from = toBytes(getAddress(opts.from))\n\n  let nonce = toBytes(opts.nonce)\n  if (nonce[0] === 0) nonce = new Uint8Array([])\n\n  return getAddress(\n    `0x${keccak256(toRlp([from, nonce], 'bytes')).slice(26)}` as Address,\n  )\n}\n\nexport function getCreate2Address(opts: GetCreate2AddressOptions) {\n  const from = toBytes(getAddress(opts.from))\n  const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt), {\n    size: 32,\n  })\n\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in opts) {\n      if (isBytes(opts.bytecodeHash)) return opts.bytecodeHash\n      return toBytes(opts.bytecodeHash)\n    }\n    return keccak256(opts.bytecode, 'bytes')\n  })()\n\n  return getAddress(\n    slice(keccak256(concat([toBytes('0xff'), from, salt, bytecodeHash])), 12),\n  )\n}\n"],"mappings":"AAGA,SAASA,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,GAAG,QAAQ,gBAAgB;AACpC,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,KAAK,QAAQ,sBAAsB;AAC5C,SAASC,SAAS,QAAQ,sBAAsB;AAEhD,SAASC,UAAU,QAAQ,iBAAiB;AAyB5C,OAAM,SAAUC,kBAAkBA,CAACC,IAA+B;EAChE,IAAIA,IAAI,CAACC,MAAM,KAAK,SAAS,EAAE,OAAOC,iBAAiB,CAACF,IAAI,CAAC;EAC7D,OAAOG,gBAAgB,CAACH,IAAI,CAAC;AAC/B;AAEA,OAAM,SAAUG,gBAAgBA,CAACH,IAA6B;EAC5D,MAAMI,IAAI,GAAGT,OAAO,CAACG,UAAU,CAACE,IAAI,CAACI,IAAI,CAAC,CAAC;EAE3C,IAAIC,KAAK,GAAGV,OAAO,CAACK,IAAI,CAACK,KAAK,CAAC;EAC/B,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAEA,KAAK,GAAG,IAAIC,UAAU,CAAC,EAAE,CAAC;EAE9C,OAAOR,UAAU,CACf,KAAKD,SAAS,CAACD,KAAK,CAAC,CAACQ,IAAI,EAAEC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,CAACX,KAAK,CAAC,EAAE,CAAC,EAAa,CACrE;AACH;AAEA,OAAM,SAAUQ,iBAAiBA,CAACF,IAA8B;EAC9D,MAAMI,IAAI,GAAGT,OAAO,CAACG,UAAU,CAACE,IAAI,CAACI,IAAI,CAAC,CAAC;EAC3C,MAAMG,IAAI,GAAGd,GAAG,CAACD,OAAO,CAACQ,IAAI,CAACO,IAAI,CAAC,GAAGP,IAAI,CAACO,IAAI,GAAGZ,OAAO,CAACK,IAAI,CAACO,IAAI,CAAC,EAAE;IACpEC,IAAI,EAAE;GACP,CAAC;EAEF,MAAMC,YAAY,GAAG,CAAC,MAAK;IACzB,IAAI,cAAc,IAAIT,IAAI,EAAE;MAC1B,IAAIR,OAAO,CAACQ,IAAI,CAACS,YAAY,CAAC,EAAE,OAAOT,IAAI,CAACS,YAAY;MACxD,OAAOd,OAAO,CAACK,IAAI,CAACS,YAAY,CAAC;;IAEnC,OAAOZ,SAAS,CAACG,IAAI,CAACU,QAAQ,EAAE,OAAO,CAAC;EAC1C,CAAC,EAAC,CAAE;EAEJ,OAAOZ,UAAU,CACfJ,KAAK,CAACG,SAAS,CAACN,MAAM,CAAC,CAACI,OAAO,CAAC,MAAM,CAAC,EAAES,IAAI,EAAEG,IAAI,EAAEE,YAAY,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAC1E;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}