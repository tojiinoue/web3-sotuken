{"ast":null,"code":"import { formatBlock } from '../../utils/formatters/block.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks(client, _ref) {\n  let {\n    blockTag = 'latest',\n    emitMissed = false,\n    emitOnBegin = false,\n    onBlock,\n    onError,\n    includeTransactions: includeTransactions_,\n    poll: poll_,\n    pollingInterval = client.pollingInterval\n  } = _ref;\n  const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';\n  const includeTransactions = includeTransactions_ !== null && includeTransactions_ !== void 0 ? includeTransactions_ : false;\n  let prevBlock;\n  const pollBlocks = () => {\n    const observerId = stringify(['watchBlocks', client.uid, emitMissed, emitOnBegin, includeTransactions, pollingInterval]);\n    return observe(observerId, {\n      onBlock,\n      onError\n    }, emit => poll(async () => {\n      try {\n        var _prevBlock, _prevBlock3;\n        const block = await getBlock(client, {\n          blockTag,\n          includeTransactions\n        });\n        if (block.number && (_prevBlock = prevBlock) !== null && _prevBlock !== void 0 && _prevBlock.number) {\n          // If the current block number is the same as the previous,\n          // we can skip.\n          if (block.number === prevBlock.number) return;\n          // If we have missed out on some previous blocks, and the\n          // `emitMissed` flag is truthy, let's emit those blocks.\n          if (block.number - prevBlock.number > 1 && emitMissed) {\n            for (let i = ((_prevBlock2 = prevBlock) === null || _prevBlock2 === void 0 ? void 0 : _prevBlock2.number) + 1n; i < block.number; i++) {\n              var _prevBlock2;\n              const block = await getBlock(client, {\n                blockNumber: i,\n                includeTransactions\n              });\n              emit.onBlock(block, prevBlock);\n              prevBlock = block;\n            }\n          }\n        }\n        if (\n        // If no previous block exists, emit.\n        !((_prevBlock3 = prevBlock) !== null && _prevBlock3 !== void 0 && _prevBlock3.number) ||\n        // If the block tag is \"pending\" with no block number, emit.\n        blockTag === 'pending' && !(block !== null && block !== void 0 && block.number) ||\n        // If the next block number is greater than the previous block number, emit.\n        // We don't want to emit blocks in the past.\n        block.number && block.number > prevBlock.number) {\n          emit.onBlock(block, prevBlock);\n          prevBlock = block;\n        }\n      } catch (err) {\n        var _emit$onError;\n        (_emit$onError = emit.onError) === null || _emit$onError === void 0 || _emit$onError.call(emit, err);\n      }\n    }, {\n      emitOnBegin,\n      interval: pollingInterval\n    }));\n  };\n  const subscribeBlocks = () => {\n    let active = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        const {\n          unsubscribe: unsubscribe_\n        } = await client.transport.subscribe({\n          params: ['newHeads'],\n          onData(data) {\n            var _client$chain;\n            if (!active) return;\n            const format = ((_client$chain = client.chain) === null || _client$chain === void 0 || (_client$chain = _client$chain.formatters) === null || _client$chain === void 0 || (_client$chain = _client$chain.block) === null || _client$chain === void 0 ? void 0 : _client$chain.format) || formatBlock;\n            const block = format(data.result);\n            onBlock(block, prevBlock);\n            prevBlock = block;\n          },\n          onError(error) {\n            onError === null || onError === void 0 || onError(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError === null || onError === void 0 || onError(err);\n      }\n    })();\n    return unsubscribe;\n  };\n  return enablePolling ? pollBlocks() : subscribeBlocks();\n}","map":{"version":3,"names":["formatBlock","observe","poll","stringify","getBlock","watchBlocks","client","_ref","blockTag","emitMissed","emitOnBegin","onBlock","onError","includeTransactions","includeTransactions_","poll_","pollingInterval","enablePolling","transport","type","prevBlock","pollBlocks","observerId","uid","emit","_prevBlock","_prevBlock3","block","number","i","_prevBlock2","blockNumber","err","_emit$onError","call","interval","subscribeBlocks","active","unsubscribe","unsubscribe_","subscribe","params","onData","data","_client$chain","format","chain","formatters","result","error"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/actions/public/watchBlocks.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetTransportConfig } from '../../types/transport.js'\nimport { formatBlock } from '../../utils/formatters/block.js'\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockReturnType, getBlock } from './getBlock.js'\n\nexport type OnBlockParameter<\n  TChain extends Chain | undefined = Chain,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = GetBlockReturnType<TChain, TIncludeTransactions, TBlockTag>\n\nexport type OnBlock<\n  TChain extends Chain | undefined = Chain,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = (\n  block: OnBlockParameter<TChain, TIncludeTransactions, TBlockTag>,\n  prevBlock:\n    | OnBlockParameter<TChain, TIncludeTransactions, TBlockTag>\n    | undefined,\n) => void\n\ntype PollOptions<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = {\n  /** The block tag. Defaults to \"latest\". */\n  blockTag?: TBlockTag | BlockTag\n  /** Whether or not to emit the missed blocks to the callback. */\n  emitMissed?: boolean\n  /** Whether or not to emit the block to the callback when the subscription opens. */\n  emitOnBegin?: boolean\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions\n  /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */\n  pollingInterval?: number\n}\n\nexport type WatchBlocksParameters<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = {\n  /** The callback to call when a new block is received. */\n  onBlock: OnBlock<TChain, TIncludeTransactions, TBlockTag>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n} & (GetTransportConfig<TTransport>['type'] extends 'webSocket'\n  ?\n      | {\n          blockTag?: never\n          emitMissed?: never\n          emitOnBegin?: never\n          includeTransactions?: never\n          /** Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`. */\n          poll?: false\n          pollingInterval?: never\n        }\n      | (PollOptions<TIncludeTransactions, TBlockTag> & { poll?: true })\n  : PollOptions<TIncludeTransactions, TBlockTag> & { poll?: true })\n\nexport type WatchBlocksReturnType = () => void\n\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks<\n  TTransport extends Transport,\n  TChain extends Chain | undefined,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n>(\n  client: Client<TTransport, TChain>,\n  {\n    blockTag = 'latest',\n    emitMissed = false,\n    emitOnBegin = false,\n    onBlock,\n    onError,\n    includeTransactions: includeTransactions_,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlocksParameters<TTransport, TChain, TIncludeTransactions, TBlockTag>,\n): WatchBlocksReturnType {\n  const enablePolling =\n    typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket'\n  const includeTransactions = includeTransactions_ ?? false\n\n  let prevBlock:\n    | GetBlockReturnType<TChain, false | TIncludeTransactions, 'latest'>\n    | undefined\n\n  const pollBlocks = () => {\n    const observerId = stringify([\n      'watchBlocks',\n      client.uid,\n      emitMissed,\n      emitOnBegin,\n      includeTransactions,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onBlock, onError }, (emit) =>\n      poll(\n        async () => {\n          try {\n            const block = await getBlock(client, {\n              blockTag,\n              includeTransactions,\n            })\n            if (block.number && prevBlock?.number) {\n              // If the current block number is the same as the previous,\n              // we can skip.\n              if (block.number === prevBlock.number) return\n\n              // If we have missed out on some previous blocks, and the\n              // `emitMissed` flag is truthy, let's emit those blocks.\n              if (block.number - prevBlock.number > 1 && emitMissed) {\n                for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n                  const block = await getBlock(client, {\n                    blockNumber: i,\n                    includeTransactions,\n                  })\n                  emit.onBlock(block as any, prevBlock as any)\n                  prevBlock = block\n                }\n              }\n            }\n\n            if (\n              // If no previous block exists, emit.\n              !prevBlock?.number ||\n              // If the block tag is \"pending\" with no block number, emit.\n              (blockTag === 'pending' && !block?.number) ||\n              // If the next block number is greater than the previous block number, emit.\n              // We don't want to emit blocks in the past.\n              (block.number && block.number > prevBlock.number)\n            ) {\n              emit.onBlock(block as any, prevBlock as any)\n              prevBlock = block as any\n            }\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin,\n          interval: pollingInterval,\n        },\n      ),\n    )\n  }\n\n  const subscribeBlocks = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['newHeads'],\n          onData(data: any) {\n            if (!active) return\n            const format =\n              client.chain?.formatters?.block?.format || formatBlock\n            const block = format(data.result)\n            onBlock(block, prevBlock as any)\n            prevBlock = block\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return unsubscribe\n  }\n\n  return enablePolling ? pollBlocks() : subscribeBlocks()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}