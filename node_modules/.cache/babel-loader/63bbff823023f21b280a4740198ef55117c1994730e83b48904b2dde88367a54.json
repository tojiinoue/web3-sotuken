{"ast":null,"code":"import { InvalidAddressError } from '../../errors/address.js';\nimport { stringToBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { isAddress } from './isAddress.js';\nexport function checksumAddress(address_, chainId) {\n  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes');\n  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase();\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase();\n    }\n  }\n  return `0x${address.join('')}`;\n}\nexport function getAddress(address, chainId) {\n  if (!isAddress(address)) throw new InvalidAddressError({\n    address\n  });\n  return checksumAddress(address, chainId);\n}","map":{"version":3,"names":["InvalidAddressError","stringToBytes","keccak256","isAddress","checksumAddress","address_","chainId","hexAddress","toLowerCase","substring","hash","address","length","split","i","toUpperCase","join","getAddress"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/address/getAddress.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport { stringToBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\n\nimport { isAddress } from './isAddress.js'\n\nexport function checksumAddress(address_: Address, chainId?: number): Address {\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  return `0x${address.join('')}`\n}\n\nexport function getAddress(address: string, chainId?: number): Address {\n  if (!isAddress(address)) throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n"],"mappings":"AAEA,SAASA,mBAAmB,QAAQ,yBAAyB;AAC7D,SAASC,aAAa,QAAQ,wBAAwB;AACtD,SAASC,SAAS,QAAQ,sBAAsB;AAEhD,SAASC,SAAS,QAAQ,gBAAgB;AAE1C,OAAM,SAAUC,eAAeA,CAACC,QAAiB,EAAEC,OAAgB;EACjE,MAAMC,UAAU,GAAGD,OAAO,GACtB,GAAGA,OAAO,GAAGD,QAAQ,CAACG,WAAW,EAAE,EAAE,GACrCH,QAAQ,CAACI,SAAS,CAAC,CAAC,CAAC,CAACD,WAAW,EAAE;EACvC,MAAME,IAAI,GAAGR,SAAS,CAACD,aAAa,CAACM,UAAU,CAAC,EAAE,OAAO,CAAC;EAE1D,MAAMI,OAAO,GAAG,CACdL,OAAO,GAAGC,UAAU,CAACE,SAAS,CAAC,GAAGH,OAAO,IAAI,CAACM,MAAM,CAAC,GAAGL,UAAU,EAClEM,KAAK,CAAC,EAAE,CAAC;EACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC9B,IAAIJ,IAAI,CAACI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAIH,OAAO,CAACG,CAAC,CAAC,EAAE;MACxCH,OAAO,CAACG,CAAC,CAAC,GAAGH,OAAO,CAACG,CAAC,CAAC,CAACC,WAAW,EAAE;;IAEvC,IAAI,CAACL,IAAI,CAACI,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,IAAIH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,EAAE;MAChDH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGH,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,CAACC,WAAW,EAAE;;;EAIjD,OAAO,KAAKJ,OAAO,CAACK,IAAI,CAAC,EAAE,CAAC,EAAE;AAChC;AAEA,OAAM,SAAUC,UAAUA,CAACN,OAAe,EAAEL,OAAgB;EAC1D,IAAI,CAACH,SAAS,CAACQ,OAAO,CAAC,EAAE,MAAM,IAAIX,mBAAmB,CAAC;IAAEW;EAAO,CAAE,CAAC;EACnE,OAAOP,eAAe,CAACO,OAAO,EAAEL,OAAO,CAAC;AAC1C"},"metadata":{},"sourceType":"module","externalDependencies":[]}