{"ast":null,"code":"import { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { InvalidInputRpcError } from '../../errors/rpc.js';\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js';\nimport { encodeEventTopics } from '../../utils/abi/encodeEventTopics.js';\nimport { formatLog } from '../../utils/formatters/log.js';\nimport { createContractEventFilter } from './createContractEventFilter.js';\nimport { getBlockNumber } from './getBlockNumber.js';\nimport { getContractEvents } from './getContractEvents.js';\nimport { getFilterChanges } from './getFilterChanges.js';\nimport { uninstallFilter } from './uninstallFilter.js';\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent.html\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent(client, _ref) {\n  let {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_\n  } = _ref;\n  const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';\n  const pollContractEvent = () => {\n    const observerId = stringify(['watchContractEvent', address, args, batch, client.uid, eventName, pollingInterval]);\n    const strict = strict_ !== null && strict_ !== void 0 ? strict_ : false;\n    return observe(observerId, {\n      onLogs,\n      onError\n    }, emit => {\n      let previousBlockNumber;\n      let filter;\n      let initialized = false;\n      const unwatch = poll(async () => {\n        if (!initialized) {\n          try {\n            filter = await createContractEventFilter(client, {\n              abi,\n              address,\n              args,\n              eventName,\n              strict\n            });\n          } catch {}\n          initialized = true;\n          return;\n        }\n        try {\n          let logs;\n          if (filter) {\n            logs = await getFilterChanges(client, {\n              filter\n            });\n          } else {\n            // If the filter doesn't exist, we will fall back to use `getLogs`.\n            // The fall back exists because some RPC Providers do not support filters.\n            // Fetch the block number to use for `getLogs`.\n            const blockNumber = await getBlockNumber(client);\n            // If the block number has changed, we will need to fetch the logs.\n            // If the block number doesn't exist, we are yet to reach the first poll interval,\n            // so do not emit any logs.\n            if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n              logs = await getContractEvents(client, {\n                abi,\n                address,\n                args,\n                fromBlock: previousBlockNumber + 1n,\n                toBlock: blockNumber,\n                strict\n              });\n            } else {\n              logs = [];\n            }\n            previousBlockNumber = blockNumber;\n          }\n          if (logs.length === 0) return;\n          if (batch) emit.onLogs(logs);else logs.forEach(log => emit.onLogs([log]));\n        } catch (err) {\n          var _emit$onError;\n          // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n          // Reinitalize the filter when this occurs\n          if (filter && err instanceof InvalidInputRpcError) initialized = false;\n          (_emit$onError = emit.onError) === null || _emit$onError === void 0 || _emit$onError.call(emit, err);\n        }\n      }, {\n        emitOnBegin: true,\n        interval: pollingInterval\n      });\n      return async () => {\n        if (filter) await uninstallFilter(client, {\n          filter\n        });\n        unwatch();\n      };\n    });\n  };\n  const subscribeContractEvent = () => {\n    let active = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        const topics = eventName ? encodeEventTopics({\n          abi: abi,\n          eventName: eventName,\n          args\n        }) : [];\n        const {\n          unsubscribe: unsubscribe_\n        } = await client.transport.subscribe({\n          params: ['logs', {\n            address,\n            topics\n          }],\n          onData(data) {\n            if (!active) return;\n            const log = data.result;\n            try {\n              const {\n                eventName,\n                args\n              } = decodeEventLog({\n                abi: abi,\n                data: log.data,\n                topics: log.topics,\n                strict: strict_\n              });\n              const formatted = formatLog(log, {\n                args,\n                eventName: eventName\n              });\n              onLogs([formatted]);\n            } catch (err) {\n              let eventName;\n              let isUnnamed;\n              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n                var _err$abiItem$inputs;\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict_) return;\n                eventName = err.abiItem.name;\n                isUnnamed = (_err$abiItem$inputs = err.abiItem.inputs) === null || _err$abiItem$inputs === void 0 ? void 0 : _err$abiItem$inputs.some(x => !('name' in x && x.name));\n              }\n              // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n              const formatted = formatLog(log, {\n                args: isUnnamed ? [] : {},\n                eventName\n              });\n              onLogs([formatted]);\n            }\n          },\n          onError(error) {\n            onError === null || onError === void 0 || onError(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError === null || onError === void 0 || onError(err);\n      }\n    })();\n    return unsubscribe;\n  };\n  return enablePolling ? pollContractEvent() : subscribeContractEvent();\n}","map":{"version":3,"names":["observe","poll","stringify","DecodeLogDataMismatch","DecodeLogTopicsMismatch","InvalidInputRpcError","decodeEventLog","encodeEventTopics","formatLog","createContractEventFilter","getBlockNumber","getContractEvents","getFilterChanges","uninstallFilter","watchContractEvent","client","_ref","abi","address","args","batch","eventName","onError","onLogs","poll_","pollingInterval","strict","strict_","enablePolling","transport","type","pollContractEvent","observerId","uid","emit","previousBlockNumber","filter","initialized","unwatch","logs","blockNumber","fromBlock","toBlock","length","forEach","log","err","_emit$onError","call","emitOnBegin","interval","subscribeContractEvent","active","unsubscribe","topics","unsubscribe_","subscribe","params","onData","data","result","formatted","isUnnamed","_err$abiItem$inputs","abiItem","name","inputs","some","x","error"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/actions/public/watchContractEvent.ts"],"sourcesContent":["import type { Abi, Address, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetEventArgs, InferEventName } from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { GetTransportConfig } from '../../types/transport.js'\n\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport { InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { LogTopic } from '../../types/misc.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport {\n  type CreateContractEventFilterParameters,\n  createContractEventFilter,\n} from './createContractEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport {\n  type GetContractEventsParameters,\n  getContractEvents,\n} from './getContractEvents.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\ntype PollOptions = {\n  /**\n   * Whether or not the transaction hashes should be batched on each invocation.\n   * @default true\n   */\n  batch?: boolean\n  /**\n   * Polling frequency (in ms). Defaults to Client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number\n}\n\nexport type WatchContractEventOnLogsParameter<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = TAbi extends Abi\n  ? Log<bigint, number, false, ExtractAbiEvent<TAbi, TEventName>, TStrict>[]\n  : Log[]\nexport type WatchContractEventOnLogsFn<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = (logs: WatchContractEventOnLogsParameter<TAbi, TEventName, TStrict>) => void\n\nexport type WatchContractEventParameters<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[]\n  /** Contract ABI. */\n  abi: TAbi\n  args?: GetEventArgs<TAbi, TEventName>\n  /** Contract event. */\n  eventName?: InferEventName<TAbi, TEventName>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchContractEventOnLogsFn<TAbi, TEventName, TStrict>\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n   * @default false\n   */\n  strict?: TStrict\n} & (GetTransportConfig<Transport>['type'] extends 'webSocket'\n  ?\n      | {\n          batch?: never\n          /**\n           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.\n           * @default false\n           */\n          poll?: false\n          pollingInterval?: never\n        }\n      | (PollOptions & {\n          /**\n           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.\n           * @default true\n           */\n          poll?: true\n        })\n  : PollOptions & {\n      poll?: true\n    })\n\nexport type WatchContractEventReturnType = () => void\n\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent.html\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent<\n  TChain extends Chain | undefined,\n  const TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n  TStrict extends boolean | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  }: WatchContractEventParameters<TAbi, TEventName, TStrict>,\n): WatchContractEventReturnType {\n  const enablePolling =\n    typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket'\n\n  const pollContractEvent = () => {\n    const observerId = stringify([\n      'watchContractEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      eventName,\n      pollingInterval,\n    ])\n    const strict = strict_ ?? false\n\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      let previousBlockNumber: bigint\n      let filter: Filter<'event', TAbi, TEventName> | undefined\n      let initialized = false\n\n      const unwatch = poll(\n        async () => {\n          if (!initialized) {\n            try {\n              filter = (await createContractEventFilter(client, {\n                abi,\n                address,\n                args,\n                eventName,\n                strict,\n              } as unknown as CreateContractEventFilterParameters)) as Filter<\n                'event',\n                TAbi,\n                TEventName\n              >\n            } catch {}\n            initialized = true\n            return\n          }\n\n          try {\n            let logs: Log[]\n            if (filter) {\n              logs = await getFilterChanges(client, { filter })\n            } else {\n              // If the filter doesn't exist, we will fall back to use `getLogs`.\n              // The fall back exists because some RPC Providers do not support filters.\n\n              // Fetch the block number to use for `getLogs`.\n              const blockNumber = await getBlockNumber(client)\n\n              // If the block number has changed, we will need to fetch the logs.\n              // If the block number doesn't exist, we are yet to reach the first poll interval,\n              // so do not emit any logs.\n              if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n                logs = await getContractEvents(client, {\n                  abi,\n                  address,\n                  args,\n                  fromBlock: previousBlockNumber + 1n,\n                  toBlock: blockNumber,\n                  strict,\n                } as {} as GetContractEventsParameters)\n              } else {\n                logs = []\n              }\n              previousBlockNumber = blockNumber\n            }\n\n            if (logs.length === 0) return\n            if (batch) emit.onLogs(logs as any)\n            else logs.forEach((log) => emit.onLogs([log] as any))\n          } catch (err) {\n            // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n            // Reinitalize the filter when this occurs\n            if (filter && err instanceof InvalidInputRpcError)\n              initialized = false\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter) await uninstallFilter(client, { filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribeContractEvent = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const topics: LogTopic[] = eventName\n          ? encodeEventTopics({\n              abi: abi,\n              eventName: eventName,\n              args,\n            } as EncodeEventTopicsParameters)\n          : []\n\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['logs', { address, topics }],\n          onData(data: any) {\n            if (!active) return\n            const log = data.result\n            try {\n              const { eventName, args } = decodeEventLog({\n                abi: abi,\n                data: log.data,\n                topics: log.topics as any,\n                strict: strict_,\n              })\n              const formatted = formatLog(log, {\n                args,\n                eventName: eventName as string,\n              })\n              onLogs([formatted] as any)\n            } catch (err) {\n              let eventName\n              let isUnnamed\n              if (\n                err instanceof DecodeLogDataMismatch ||\n                err instanceof DecodeLogTopicsMismatch\n              ) {\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict_) return\n                eventName = err.abiItem.name\n                isUnnamed = err.abiItem.inputs?.some(\n                  (x) => !('name' in x && x.name),\n                )\n              }\n\n              // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n              const formatted = formatLog(log, {\n                args: isUnnamed ? [] : {},\n                eventName,\n              })\n              onLogs([formatted] as any)\n            }\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return unsubscribe\n  }\n\n  return enablePolling ? pollContractEvent() : subscribeContractEvent()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}