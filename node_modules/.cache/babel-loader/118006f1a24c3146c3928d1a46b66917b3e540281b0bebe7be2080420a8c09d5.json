{"ast":null,"code":"import { AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, InvalidAbiEncodingTypeError, InvalidArrayError } from '../../errors/abi.js';\nimport { InvalidAddressError } from '../../errors/address.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concat } from '../data/concat.js';\nimport { padHex } from '../data/pad.js';\nimport { size } from '../data/size.js';\nimport { slice } from '../data/slice.js';\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js';\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n */\nexport function encodeAbiParameters(params, values) {\n  if (params.length !== values.length) throw new AbiEncodingLengthMismatchError({\n    expectedLength: params.length,\n    givenLength: values.length\n  });\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params,\n    values\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) return '0x';\n  return data;\n}\nfunction prepareParams(_ref) {\n  let {\n    params,\n    values\n  } = _ref;\n  const preparedParams = [];\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({\n      param: params[i],\n      value: values[i]\n    }));\n  }\n  return preparedParams;\n}\nfunction prepareParam(_ref2) {\n  let {\n    param,\n    value\n  } = _ref2;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      length,\n      param: {\n        ...param,\n        type\n      }\n    });\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value, {\n      param: param\n    });\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value);\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value);\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int');\n    return encodeNumber(value, {\n      signed\n    });\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value, {\n      param\n    });\n  }\n  if (param.type === 'string') {\n    return encodeString(value);\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters'\n  });\n}\n/////////////////////////////////////////////////////////////////\nfunction encodeParams(preparedParams) {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) staticSize += 32;else staticSize += size(encoded);\n  }\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams = [];\n  const dynamicParams = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParams.push(encoded);\n      dynamicSize += size(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams]);\n}\n/////////////////////////////////////////////////////////////////\nfunction encodeAddress(value) {\n  if (!isAddress(value)) throw new InvalidAddressError({\n    address: value\n  });\n  return {\n    dynamic: false,\n    encoded: padHex(value.toLowerCase())\n  };\n}\nfunction encodeArray(value, _ref3) {\n  let {\n    length,\n    param\n  } = _ref3;\n  const dynamic = length === null;\n  if (!Array.isArray(value)) throw new InvalidArrayError(value);\n  if (!dynamic && value.length !== length) throw new AbiEncodingArrayLengthMismatchError({\n    expectedLength: length,\n    givenLength: value.length,\n    type: `${param.type}[${length}]`\n  });\n  let dynamicChild = false;\n  const preparedParams = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({\n      param,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) dynamicChild = true;\n    preparedParams.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length\n      };\n    }\n    if (dynamicChild) return {\n      dynamic: true,\n      encoded: data\n    };\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(_ref4 => {\n      let {\n        encoded\n      } = _ref4;\n      return encoded;\n    }))\n  };\n}\nfunction encodeBytes(value, _ref5) {\n  let {\n    param\n  } = _ref5;\n  const [, paramSize] = param.type.split('bytes');\n  const bytesSize = size(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) value_ = padHex(value_, {\n      dir: 'right',\n      size: Math.ceil((value.length - 2) / 2 / 32) * 32\n    });\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, {\n        size: 32\n      })), value_])\n    };\n  }\n  if (bytesSize !== parseInt(paramSize)) throw new AbiEncodingBytesSizeMismatchError({\n    expectedSize: parseInt(paramSize),\n    value\n  });\n  return {\n    dynamic: false,\n    encoded: padHex(value, {\n      dir: 'right'\n    })\n  };\n}\nfunction encodeBool(value) {\n  return {\n    dynamic: false,\n    encoded: padHex(boolToHex(value))\n  };\n}\nfunction encodeNumber(value, _ref6) {\n  let {\n    signed\n  } = _ref6;\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed\n    })\n  };\n}\nfunction encodeString(value) {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(size(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n      dir: 'right'\n    }));\n  }\n  return {\n    dynamic: true,\n    encoded: concat([padHex(numberToHex(size(hexValue), {\n      size: 32\n    })), ...parts])\n  };\n}\nfunction encodeTuple(value, _ref7) {\n  let {\n    param\n  } = _ref7;\n  let dynamic = false;\n  const preparedParams = [];\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      value: value[index]\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) dynamic = true;\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(_ref8 => {\n      let {\n        encoded\n      } = _ref8;\n      return encoded;\n    }))\n  };\n}\nexport function getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ?\n  // Return `null` if the array is dynamic.\n  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}","map":{"version":3,"names":["AbiEncodingArrayLengthMismatchError","AbiEncodingBytesSizeMismatchError","AbiEncodingLengthMismatchError","InvalidAbiEncodingTypeError","InvalidArrayError","InvalidAddressError","isAddress","concat","padHex","size","slice","boolToHex","numberToHex","stringToHex","encodeAbiParameters","params","values","length","expectedLength","givenLength","preparedParams","prepareParams","data","encodeParams","_ref","i","push","prepareParam","param","value","_ref2","arrayComponents","getArrayComponents","type","encodeArray","encodeTuple","encodeAddress","encodeBool","startsWith","signed","encodeNumber","encodeBytes","encodeString","docsPath","staticSize","dynamic","encoded","staticParams","dynamicParams","dynamicSize","address","toLowerCase","_ref3","Array","isArray","dynamicChild","preparedParam","map","_ref4","_ref5","paramSize","split","bytesSize","value_","dir","Math","ceil","parseInt","expectedSize","_ref6","hexValue","partsLength","parts","_ref7","components","param_","index","name","_ref8","matches","match","Number","undefined"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/abi/encodeAbiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  AbiEncodingBytesSizeMismatchError,\n  AbiEncodingLengthMismatchError,\n  InvalidAbiEncodingTypeError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { Hex } from '../../types/misc.js'\nimport { isAddress } from '../address/isAddress.js'\nimport { concat } from '../data/concat.js'\nimport { padHex } from '../data/pad.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams\n  values: AbiParametersToPrimitiveTypes<TParams>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\nfunction prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam\n  value: AbiParameterToPrimitiveType<TParam>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    return encodeNumber(value as unknown as number, { signed })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: TParam\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: parseInt(paramSize),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}