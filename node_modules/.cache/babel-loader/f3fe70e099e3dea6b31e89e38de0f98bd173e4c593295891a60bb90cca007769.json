{"ast":null,"code":"export const listenersCache = /*#__PURE__*/new Map();\nexport const cleanupCache = /*#__PURE__*/new Map();\nlet callbackCount = 0;\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe(observerId, callbacks, fn) {\n  const callbackId = ++callbackCount;\n  const getListeners = () => listenersCache.get(observerId) || [];\n  const unsubscribe = () => {\n    const listeners = getListeners();\n    listenersCache.set(observerId, listeners.filter(cb => cb.id !== callbackId));\n  };\n  const unwatch = () => {\n    const cleanup = cleanupCache.get(observerId);\n    if (getListeners().length === 1 && cleanup) cleanup();\n    unsubscribe();\n  };\n  const listeners = getListeners();\n  listenersCache.set(observerId, [...listeners, {\n    id: callbackId,\n    fns: callbacks\n  }]);\n  if (listeners && listeners.length > 0) return unwatch;\n  const emit = {};\n  for (const key in callbacks) {\n    emit[key] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const listeners = getListeners();\n      if (listeners.length === 0) return;\n      listeners.forEach(listener => {\n        var _listener$fns$key, _listener$fns;\n        return (_listener$fns$key = (_listener$fns = listener.fns)[key]) === null || _listener$fns$key === void 0 ? void 0 : _listener$fns$key.call(_listener$fns, ...args);\n      });\n    };\n  }\n  const cleanup = fn(emit);\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup);\n  return unwatch;\n}","map":{"version":3,"names":["listenersCache","Map","cleanupCache","callbackCount","observe","observerId","callbacks","fn","callbackId","getListeners","get","unsubscribe","listeners","set","filter","cb","id","unwatch","cleanup","length","fns","emit","key","_len","arguments","args","Array","_key","forEach","listener","_listener$fns$key","_listener$fns","call"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/observe.ts"],"sourcesContent":["import type { MaybePromise } from '../types/utils.js'\n\ntype Callback = ((...args: any[]) => any) | undefined\ntype Callbacks = Record<string, Callback>\n\nexport const listenersCache = /*#__PURE__*/ new Map<\n  string,\n  { id: number; fns: Callbacks }[]\n>()\nexport const cleanupCache = /*#__PURE__*/ new Map<string, () => void>()\n\ntype EmitFunction<TCallbacks extends Callbacks> = (\n  emit: TCallbacks,\n) => MaybePromise<void | (() => void)>\n\nlet callbackCount = 0\n\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe<TCallbacks extends Callbacks>(\n  observerId: string,\n  callbacks: TCallbacks,\n  fn: EmitFunction<TCallbacks>,\n) {\n  const callbackId = ++callbackCount\n\n  const getListeners = () => listenersCache.get(observerId) || []\n\n  const unsubscribe = () => {\n    const listeners = getListeners()\n    listenersCache.set(\n      observerId,\n      listeners.filter((cb: any) => cb.id !== callbackId),\n    )\n  }\n\n  const unwatch = () => {\n    const cleanup = cleanupCache.get(observerId)\n    if (getListeners().length === 1 && cleanup) cleanup()\n    unsubscribe()\n  }\n\n  const listeners = getListeners()\n  listenersCache.set(observerId, [\n    ...listeners,\n    { id: callbackId, fns: callbacks },\n  ])\n\n  if (listeners && listeners.length > 0) return unwatch\n\n  const emit: TCallbacks = {} as TCallbacks\n  for (const key in callbacks) {\n    emit[key] = ((\n      ...args: Parameters<NonNullable<TCallbacks[keyof TCallbacks]>>\n    ) => {\n      const listeners = getListeners()\n      if (listeners.length === 0) return\n      listeners.forEach((listener) => listener.fns[key]?.(...args))\n    }) as TCallbacks[Extract<keyof TCallbacks, string>]\n  }\n\n  const cleanup = fn(emit)\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup)\n\n  return unwatch\n}\n"],"mappings":"AAKA,OAAO,MAAMA,cAAc,GAAG,aAAc,IAAIC,GAAG,EAGhD;AACH,OAAO,MAAMC,YAAY,GAAG,aAAc,IAAID,GAAG,EAAsB;AAMvE,IAAIE,aAAa,GAAG,CAAC;AAErB;;;;;AAKA,OAAM,SAAUC,OAAOA,CACrBC,UAAkB,EAClBC,SAAqB,EACrBC,EAA4B;EAE5B,MAAMC,UAAU,GAAG,EAAEL,aAAa;EAElC,MAAMM,YAAY,GAAGA,CAAA,KAAMT,cAAc,CAACU,GAAG,CAACL,UAAU,CAAC,IAAI,EAAE;EAE/D,MAAMM,WAAW,GAAGA,CAAA,KAAK;IACvB,MAAMC,SAAS,GAAGH,YAAY,EAAE;IAChCT,cAAc,CAACa,GAAG,CAChBR,UAAU,EACVO,SAAS,CAACE,MAAM,CAAEC,EAAO,IAAKA,EAAE,CAACC,EAAE,KAAKR,UAAU,CAAC,CACpD;EACH,CAAC;EAED,MAAMS,OAAO,GAAGA,CAAA,KAAK;IACnB,MAAMC,OAAO,GAAGhB,YAAY,CAACQ,GAAG,CAACL,UAAU,CAAC;IAC5C,IAAII,YAAY,EAAE,CAACU,MAAM,KAAK,CAAC,IAAID,OAAO,EAAEA,OAAO,EAAE;IACrDP,WAAW,EAAE;EACf,CAAC;EAED,MAAMC,SAAS,GAAGH,YAAY,EAAE;EAChCT,cAAc,CAACa,GAAG,CAACR,UAAU,EAAE,CAC7B,GAAGO,SAAS,EACZ;IAAEI,EAAE,EAAER,UAAU;IAAEY,GAAG,EAAEd;EAAS,CAAE,CACnC,CAAC;EAEF,IAAIM,SAAS,IAAIA,SAAS,CAACO,MAAM,GAAG,CAAC,EAAE,OAAOF,OAAO;EAErD,MAAMI,IAAI,GAAe,EAAgB;EACzC,KAAK,MAAMC,GAAG,IAAIhB,SAAS,EAAE;IAC3Be,IAAI,CAACC,GAAG,CAAC,GAAI,YAET;MAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAL,MAAA,EADCM,IAA2D,OAAAC,KAAA,CAAAH,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;QAA3DF,IAA2D,CAAAE,IAAA,IAAAH,SAAA,CAAAG,IAAA;MAAA;MAE9D,MAAMf,SAAS,GAAGH,YAAY,EAAE;MAChC,IAAIG,SAAS,CAACO,MAAM,KAAK,CAAC,EAAE;MAC5BP,SAAS,CAACgB,OAAO,CAAEC,QAAQ;QAAA,IAAAC,iBAAA,EAAAC,aAAA;QAAA,QAAAD,iBAAA,GAAK,CAAAC,aAAA,GAAAF,QAAQ,CAACT,GAAG,EAACE,GAAG,CAAC,cAAAQ,iBAAA,uBAAjBA,iBAAA,CAAAE,IAAA,CAAAD,aAAA,EAAoB,GAAGN,IAAI,CAAC;MAAA,EAAC;IAC/D,CAAmD;;EAGrD,MAAMP,OAAO,GAAGX,EAAE,CAACc,IAAI,CAAC;EACxB,IAAI,OAAOH,OAAO,KAAK,UAAU,EAAEhB,YAAY,CAACW,GAAG,CAACR,UAAU,EAAEa,OAAO,CAAC;EAExE,OAAOD,OAAO;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}