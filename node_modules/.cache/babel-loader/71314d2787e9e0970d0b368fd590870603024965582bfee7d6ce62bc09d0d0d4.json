{"ast":null,"code":"import { AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, InvalidAbiDecodingTypeError } from '../../errors/abi.js';\nimport { checksumAddress } from '../address/getAddress.js';\nimport { size } from '../data/size.js';\nimport { slice } from '../data/slice.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBigInt, hexToBool, hexToNumber, hexToString } from '../encoding/fromHex.js';\nimport { getArrayComponents } from './encodeAbiParameters.js';\nexport function decodeAbiParameters(params, data) {\n  if (data === '0x' && params.length > 0) throw new AbiDecodingZeroDataError();\n  if (size(data) && size(data) < 32) throw new AbiDecodingDataSizeTooSmallError({\n    data,\n    params: params,\n    size: size(data)\n  });\n  return decodeParams({\n    data,\n    params: params\n  });\n}\nfunction decodeParams(_ref) {\n  let {\n    data,\n    params\n  } = _ref;\n  const decodedValues = [];\n  let position = 0;\n  for (let i = 0; i < params.length; i++) {\n    if (position >= size(data)) throw new AbiDecodingDataSizeTooSmallError({\n      data,\n      params,\n      size: size(data)\n    });\n    const param = params[i];\n    const {\n      consumed,\n      value\n    } = decodeParam({\n      data,\n      param,\n      position\n    });\n    decodedValues.push(value);\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed;\n  }\n  return decodedValues;\n}\nfunction decodeParam(_ref2) {\n  let {\n    data,\n    param,\n    position\n  } = _ref2;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(data, {\n      length,\n      param: {\n        ...param,\n        type: type\n      },\n      position\n    });\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, {\n      param: param,\n      position\n    });\n  }\n  if (param.type === 'string') {\n    return decodeString(data, {\n      position\n    });\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, {\n      param,\n      position\n    });\n  }\n  const value = slice(data, position, position + 32, {\n    strict: true\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, {\n      param\n    });\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value);\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value);\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters'\n  });\n}\n////////////////////////////////////////////////////////////////////\nfunction decodeAddress(value) {\n  return {\n    consumed: 32,\n    value: checksumAddress(slice(value, -20))\n  };\n}\nfunction decodeArray(data, _ref3) {\n  let {\n    param,\n    length,\n    position\n  } = _ref3;\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(slice(data, position, position + 32, {\n      strict: true\n    }));\n    // Get the length of the array from the offset.\n    const length = hexToNumber(slice(data, offset, offset + 32, {\n      strict: true\n    }));\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed\n      });\n      consumed += decodedChild.consumed;\n      value.push(decodedChild.value);\n    }\n    return {\n      value,\n      consumed: 32\n    };\n  }\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type);\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !(arrayComponents !== null && arrayComponents !== void 0 && arrayComponents[0]);\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(slice(data, position, position + 32, {\n        strict: true\n      }));\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32\n      });\n      consumed += decodedChild.consumed;\n      value.push(decodedChild.value);\n    }\n    return {\n      value,\n      consumed: 32\n    };\n  }\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed\n    });\n    consumed += decodedChild.consumed;\n    value.push(decodedChild.value);\n  }\n  return {\n    value,\n    consumed\n  };\n}\nfunction decodeBool(value) {\n  return {\n    consumed: 32,\n    value: hexToBool(value)\n  };\n}\nfunction decodeBytes(data, _ref4) {\n  let {\n    param,\n    position\n  } = _ref4;\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(slice(data, position, position + 32, {\n      strict: true\n    }));\n    const length = hexToNumber(slice(data, offset, offset + 32, {\n      strict: true\n    }));\n    // If there is no length, we have zero data.\n    if (length === 0) return {\n      consumed: 32,\n      value: '0x'\n    };\n    const value = slice(data, offset + 32, offset + 32 + length, {\n      strict: true\n    });\n    return {\n      consumed: 32,\n      value\n    };\n  }\n  const value = slice(data, position, position + parseInt(size), {\n    strict: true\n  });\n  return {\n    consumed: 32,\n    value\n  };\n}\nfunction decodeNumber(value, _ref5) {\n  let {\n    param\n  } = _ref5;\n  const signed = param.type.startsWith('int');\n  const size = parseInt(param.type.split('int')[1] || '256');\n  return {\n    consumed: 32,\n    value: size > 48 ? hexToBigInt(value, {\n      signed\n    }) : hexToNumber(value, {\n      signed\n    })\n  };\n}\nfunction decodeString(data, _ref6) {\n  let {\n    position\n  } = _ref6;\n  const offset = hexToNumber(slice(data, position, position + 32, {\n    strict: true\n  }));\n  const length = hexToNumber(slice(data, offset, offset + 32, {\n    strict: true\n  }));\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) return {\n    consumed: 32,\n    value: ''\n  };\n  const value = hexToString(trim(slice(data, offset + 32, offset + 32 + length, {\n    strict: true\n  })));\n  return {\n    consumed: 32,\n    value\n  };\n}\nfunction decodeTuple(data, _ref7) {\n  let {\n    param,\n    position\n  } = _ref7;\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(_ref8 => {\n    let {\n      name\n    } = _ref8;\n    return !name;\n  });\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(slice(data, position, position + 32, {\n      strict: true\n    }));\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed\n      });\n      consumed += decodedChild.consumed;\n      value[hasUnnamedChild ? i : component === null || component === void 0 ? void 0 : component.name] = decodedChild.value;\n    }\n    return {\n      consumed: 32,\n      value\n    };\n  }\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed\n    });\n    consumed += decodedChild.consumed;\n    value[hasUnnamedChild ? i : component === null || component === void 0 ? void 0 : component.name] = decodedChild.value;\n  }\n  return {\n    consumed,\n    value\n  };\n}\nfunction hasDynamicChild(param) {\n  var _param$components;\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return (_param$components = param.components) === null || _param$components === void 0 ? void 0 : _param$components.some(hasDynamicChild);\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["AbiDecodingDataSizeTooSmallError","AbiDecodingZeroDataError","InvalidAbiDecodingTypeError","checksumAddress","size","slice","trim","hexToBigInt","hexToBool","hexToNumber","hexToString","getArrayComponents","decodeAbiParameters","params","data","length","decodeParams","_ref","decodedValues","position","i","param","consumed","value","decodeParam","push","_ref2","arrayComponents","type","decodeArray","decodeTuple","decodeString","startsWith","decodeBytes","strict","decodeNumber","decodeAddress","decodeBool","docsPath","_ref3","offset","decodedChild","hasDynamicChild","dynamicChild","_ref4","_","split","parseInt","_ref5","signed","_ref6","_ref7","hasUnnamedChild","components","some","_ref8","name","component","_param$components","endsWith"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/utils/abi/decodeAbiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n} from '../../errors/abi.js'\nimport type { Hex } from '../../types/misc.js'\nimport { checksumAddress } from '../address/getAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { trim } from '../data/trim.js'\nimport {\n  hexToBigInt,\n  hexToBool,\n  hexToNumber,\n  hexToString,\n} from '../encoding/fromHex.js'\n\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  TParams extends\n    | readonly AbiParameter[]\n    | readonly unknown[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  TParams extends readonly AbiParameter[] ? TParams : AbiParameter[]\n>\n\nexport function decodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(params: TParams, data: Hex): DecodeAbiParametersReturnType<TParams> {\n  if (data === '0x' && (params as unknown[]).length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data,\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n  return decodeParams({\n    data,\n    params: params as readonly AbiParameter[],\n  }) as unknown as DecodeAbiParametersReturnType<TParams>\n}\n\n////////////////////////////////////////////////////////////////////\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\nfunction decodeParams<const TParams extends readonly AbiParameter[]>({\n  data,\n  params,\n}: { data: Hex; params: TParams }) {\n  const decodedValues: unknown[] = []\n  let position = 0\n\n  for (let i = 0; i < params.length; i++) {\n    if (position >= size(data))\n      throw new AbiDecodingDataSizeTooSmallError({\n        data,\n        params,\n        size: size(data),\n      })\n\n    const param = params[i]\n    const { consumed, value } = decodeParam({ data, param, position })\n    decodedValues.push(value)\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed\n  }\n\n  return decodedValues as unknown as AbiParametersToPrimitiveTypes<TParams>\n}\n\nfunction decodeParam({\n  data,\n  param,\n  position,\n}: { data: Hex; param: AbiParameter; position: number }): {\n  consumed: number\n  value: any\n} {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(data, {\n      length,\n      param: { ...param, type: type } as AbiParameter,\n      position,\n    })\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, { param: param as TupleAbiParameter, position })\n  }\n  if (param.type === 'string') {\n    return decodeString(data, { position })\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, { param, position })\n  }\n\n  const value = slice(data, position, position + 32, { strict: true }) as Hex\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, { param })\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value)\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value)\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n\nfunction decodeAddress(value: Hex) {\n  return { consumed: 32, value: checksumAddress(slice(value, -20)) }\n}\n\nfunction decodeArray<const TParam extends AbiParameter>(\n  data: Hex,\n  {\n    param,\n    length,\n    position,\n  }: {\n    param: TParam\n    length: number | null\n    position: number\n  },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Get the length of the array from the offset.\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type)\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !arrayComponents?.[0]\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(\n        slice(data, position, position + 32, { strict: true }),\n      )\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0\n  const value: AbiParameterToPrimitiveType<TParam>[] = []\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value.push(decodedChild.value)\n  }\n  return { value, consumed }\n}\n\nfunction decodeBool(value: Hex) {\n  return { consumed: 32, value: hexToBool(value) }\n}\n\nfunction decodeBytes<const TParam extends AbiParameter>(\n  data: Hex,\n  { param, position }: { param: TParam; position: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n    // If there is no length, we have zero data.\n    if (length === 0) return { consumed: 32, value: '0x' }\n    const value = slice(data, offset + 32, offset + 32 + length, {\n      strict: true,\n    })\n    return { consumed: 32, value }\n  }\n\n  const value = slice(data, position, position + parseInt(size), {\n    strict: true,\n  })\n  return { consumed: 32, value }\n}\n\nfunction decodeNumber<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n) {\n  const signed = param.type.startsWith('int')\n  const size = parseInt(param.type.split('int')[1] || '256')\n  return {\n    consumed: 32,\n    value:\n      size > 48\n        ? hexToBigInt(value, { signed })\n        : hexToNumber(value, { signed }),\n  }\n}\n\nfunction decodeString(data: Hex, { position }: { position: number }) {\n  const offset = hexToNumber(\n    slice(data, position, position + 32, { strict: true }),\n  )\n  const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }))\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) return { consumed: 32, value: '' }\n  const value = hexToString(\n    trim(slice(data, offset + 32, offset + 32 + length, { strict: true })),\n  )\n  return { consumed: 32, value }\n}\n\nfunction decodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(data: Hex, { param, position }: { param: TParam; position: number }) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n    }\n    return { consumed: 32, value }\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n  }\n  return { consumed, value }\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}