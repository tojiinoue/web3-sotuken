{"ast":null,"code":"import { getChainContractAddress } from '../../utils/chain.js';\nimport { toHex } from '../../utils/encoding/toHex.js';\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js';\nimport { readContract } from '../public/readContract.js';\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wagmi-dev.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver(client, _ref) {\n  let {\n    blockNumber,\n    blockTag,\n    name,\n    universalResolverAddress: universalResolverAddress_\n  } = _ref;\n  let universalResolverAddress = universalResolverAddress_;\n  if (!universalResolverAddress) {\n    if (!client.chain) throw new Error('client chain not configured. universalResolverAddress is required.');\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver'\n    });\n  }\n  const [resolverAddress] = await readContract(client, {\n    address: universalResolverAddress,\n    abi: [{\n      inputs: [{\n        type: 'bytes'\n      }],\n      name: 'findResolver',\n      outputs: [{\n        type: 'address'\n      }, {\n        type: 'bytes32'\n      }],\n      stateMutability: 'view',\n      type: 'function'\n    }],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag\n  });\n  return resolverAddress;\n}","map":{"version":3,"names":["getChainContractAddress","toHex","packetToBytes","readContract","getEnsResolver","client","_ref","blockNumber","blockTag","name","universalResolverAddress","universalResolverAddress_","chain","Error","contract","resolverAddress","address","abi","inputs","type","outputs","stateMutability","functionName","args"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/viem/actions/ens/getEnsResolver.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { toHex } from '../../utils/encoding/toHex.js'\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsResolverParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsResolverReturnType = Address\n\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wagmi-dev.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    name,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsResolverParameters,\n) {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver',\n    })\n  }\n\n  const [resolverAddress] = await readContract(client, {\n    address: universalResolverAddress,\n    abi: [\n      {\n        inputs: [{ type: 'bytes' }],\n        name: 'findResolver',\n        outputs: [{ type: 'address' }, { type: 'bytes32' }],\n        stateMutability: 'view',\n        type: 'function',\n      },\n    ],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag,\n  })\n  return resolverAddress\n}\n"],"mappings":"AAMA,SAASA,uBAAuB,QAAQ,sBAAsB;AAC9D,SAASC,KAAK,QAAQ,+BAA+B;AACrD,SAASC,aAAa,QAAQ,kCAAkC;AAChE,SAEEC,YAAY,QACP,2BAA2B;AAalC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,OAAO,eAAeC,cAAcA,CAClCC,MAAiC,EAAAC,IAAA,EAMN;EAAA,IAL3B;IACEC,WAAW;IACXC,QAAQ;IACRC,IAAI;IACJC,wBAAwB,EAAEC;EAAyB,CAC1B,GAAAL,IAAA;EAE3B,IAAII,wBAAwB,GAAGC,yBAAyB;EACxD,IAAI,CAACD,wBAAwB,EAAE;IAC7B,IAAI,CAACL,MAAM,CAACO,KAAK,EACf,MAAM,IAAIC,KAAK,CACb,oEAAoE,CACrE;IAEHH,wBAAwB,GAAGV,uBAAuB,CAAC;MACjDO,WAAW;MACXK,KAAK,EAAEP,MAAM,CAACO,KAAK;MACnBE,QAAQ,EAAE;KACX,CAAC;;EAGJ,MAAM,CAACC,eAAe,CAAC,GAAG,MAAMZ,YAAY,CAACE,MAAM,EAAE;IACnDW,OAAO,EAAEN,wBAAwB;IACjCO,GAAG,EAAE,CACH;MACEC,MAAM,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAO,CAAE,CAAC;MAC3BV,IAAI,EAAE,cAAc;MACpBW,OAAO,EAAE,CAAC;QAAED,IAAI,EAAE;MAAS,CAAE,EAAE;QAAEA,IAAI,EAAE;MAAS,CAAE,CAAC;MACnDE,eAAe,EAAE,MAAM;MACvBF,IAAI,EAAE;KACP,CACF;IACDG,YAAY,EAAE,cAAc;IAC5BC,IAAI,EAAE,CAACtB,KAAK,CAACC,aAAa,CAACO,IAAI,CAAC,CAAC,CAAC;IAClCF,WAAW;IACXC;GACD,CAAC;EACF,OAAOO,eAAe;AACxB"},"metadata":{},"sourceType":"module","externalDependencies":[]}