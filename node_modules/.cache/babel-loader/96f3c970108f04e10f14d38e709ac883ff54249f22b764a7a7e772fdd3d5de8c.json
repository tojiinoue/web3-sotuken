{"ast":null,"code":"/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Selectors} Selectors\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<RuleSet> | undefined} descendant\n *   `a b`\n * @property {Array<RuleSet> | undefined} directChild\n *   `a > b`\n * @property {Array<RuleSet> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<RuleSet> | undefined} generalSibling\n *   `a ~ b`\n *\n * @typedef Counts\n *   Info on elements in a parent.\n * @property {number} count\n *   Number of elements.\n * @property {Map<string, number>} types\n *   Number of elements by tag name.\n */\n\nimport { enterState } from './enter-state.js';\nimport { test } from './test.js';\n\n/** @type {Array<never>} */\nconst empty = [];\n\n/**\n * Turn a query into a uniform object.\n *\n * @param {Selectors | RuleSet | null} query\n * @returns {Selectors}\n */\nexport function queryToSelectors(query) {\n  if (query === null) {\n    return {\n      type: 'selectors',\n      selectors: []\n    };\n  }\n  if (query.type === 'ruleSet') {\n    return {\n      type: 'selectors',\n      selectors: [query]\n    };\n  }\n  return query;\n}\n\n/**\n * Walk a tree.\n *\n * @param {SelectState} state\n * @param {Node | undefined} tree\n */\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined);\n  }\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Array<RuleSet>} currentRules\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @returns {Nest}\n */\nfunction one(state, currentRules, node, index, parent) {\n  /** @type {Nest} */\n  let nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  };\n  const exit = enterState(state, node);\n  if (node.type === 'element') {\n    nestResult = applySelectors(state,\n    // Try the root rules for this element too.\n    combine(currentRules, state.rootQuery.selectors), node, index, parent);\n  }\n\n  // If this is a parent, and we want to delve into them, and we haven’t found\n  // our single result yet.\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node);\n  }\n  exit();\n  return nestResult;\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Nest} nest\n * @param {Parent} node\n * @returns {void}\n */\nfunction all(state, nest, node) {\n  const fromParent = combine(nest.descendant, nest.directChild);\n  /** @type {Array<RuleSet> | undefined} */\n  let fromSibling;\n  let index = -1;\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n  const total = {\n    count: 0,\n    types: new Map()\n  };\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n  const before = {\n    count: 0,\n    types: new Map()\n  };\n  while (++index < node.children.length) {\n    count(total, node.children[index]);\n  }\n  index = -1;\n  while (++index < node.children.length) {\n    const child = node.children[index];\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = child.type === 'element' ? child.tagName.toUpperCase() : undefined;\n    // Before counting further elements:\n    state.elementIndex = before.count;\n    state.typeIndex = name ? before.types.get(name) || 0 : 0;\n    // After counting all elements.\n    state.elementCount = total.count;\n    state.typeCount = name ? total.types.get(name) : 0;\n\n    // Only apply if this is a parent, this should be an element, but we check\n    // for parents so that we delve into custom nodes too.\n    if ('children' in child) {\n      const forSibling = combine(fromParent, fromSibling);\n      const nest = one(state, forSibling, node.children[index], index, node);\n      fromSibling = combine(nest.generalSibling, nest.adjacentSibling);\n    }\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break;\n    }\n    count(before, node.children[index]);\n  }\n}\n\n/**\n * Apply selectors to an element.\n *\n * @param {SelectState} state\n *   Current state.\n * @param {Array<RuleSet>} rules\n *   Rules to apply.\n * @param {Element} node\n *   Element to apply rules to.\n * @param {number | undefined} index\n *   Index of node in parent.\n * @param {Parent | undefined} parent\n *   Parent of node.\n * @returns {Nest}\n *   Further rules.\n */\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  };\n  let selectorIndex = -1;\n  while (++selectorIndex < rules.length) {\n    const ruleSet = rules[selectorIndex];\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break;\n    }\n\n    // When shallow, we don’t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n    if (state.shallow && ruleSet.rule.rule) {\n      throw new Error('Expected selector without nesting');\n    }\n\n    // If this rule matches:\n    if (test(ruleSet.rule, node, index, parent, state)) {\n      const nest = ruleSet.rule.rule;\n\n      // Are there more?\n      if (nest) {\n        /** @type {RuleSet} */\n        const rule = {\n          type: 'ruleSet',\n          rule: nest\n        };\n        /** @type {keyof Nest} */\n        const label = nest.nestingOperator === '+' ? 'adjacentSibling' : nest.nestingOperator === '~' ? 'generalSibling' : nest.nestingOperator === '>' ? 'directChild' : 'descendant';\n        add(nestResult, label, rule);\n      } else {\n        // We have a match!\n        state.found = true;\n        if (!state.results.includes(node)) {\n          state.results.push(node);\n        }\n      }\n    }\n\n    // Descendant.\n    if (ruleSet.rule.nestingOperator === null) {\n      add(nestResult, 'descendant', ruleSet);\n    }\n    // Adjacent.\n    else if (ruleSet.rule.nestingOperator === '~') {\n      add(nestResult, 'generalSibling', ruleSet);\n    }\n    // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).\n  }\n\n  return nestResult;\n}\n\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<RuleSet> | undefined} left\n * @param {Array<RuleSet> | undefined} right\n * @returns {Array<RuleSet>}\n */\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0 ? [...left, ...right] : left && left.length > 0 ? left : right && right.length > 0 ? right : empty;\n}\n\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n * @param {keyof Nest} field\n * @param {RuleSet} rule\n */\nfunction add(nest, field, rule) {\n  const list = nest[field];\n  if (list) {\n    list.push(rule);\n  } else {\n    nest[field] = [rule];\n  }\n}\n\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Node} node\n *   Node (we’re looking for elements).\n * @returns {void}\n *   Nothing.\n */\nfunction count(counts, node) {\n  if (node.type === 'element') {\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = node.tagName.toUpperCase();\n    const count = (counts.types.get(name) || 0) + 1;\n    counts.count++;\n    counts.types.set(name, count);\n  }\n}","map":{"version":3,"names":["enterState","test","empty","queryToSelectors","query","type","selectors","walk","state","tree","one","undefined","currentRules","node","index","parent","nestResult","directChild","descendant","adjacentSibling","generalSibling","exit","applySelectors","combine","rootQuery","shallow","found","all","nest","fromParent","fromSibling","total","count","types","Map","before","children","length","child","name","tagName","toUpperCase","elementIndex","typeIndex","get","elementCount","typeCount","forSibling","rules","selectorIndex","ruleSet","rule","Error","label","nestingOperator","add","results","includes","push","left","right","field","list","counts","set"],"sources":["/Users/toji.inoue/Desktop/卒業研究_井上登司フォルダ/web3-sotuken/node_modules/hast-util-select/lib/walk.js"],"sourcesContent":["/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Selectors} Selectors\n *\n * @typedef Nest\n *   Rule sets by nesting.\n * @property {Array<RuleSet> | undefined} descendant\n *   `a b`\n * @property {Array<RuleSet> | undefined} directChild\n *   `a > b`\n * @property {Array<RuleSet> | undefined} adjacentSibling\n *   `a + b`\n * @property {Array<RuleSet> | undefined} generalSibling\n *   `a ~ b`\n *\n * @typedef Counts\n *   Info on elements in a parent.\n * @property {number} count\n *   Number of elements.\n * @property {Map<string, number>} types\n *   Number of elements by tag name.\n */\n\nimport {enterState} from './enter-state.js'\nimport {test} from './test.js'\n\n/** @type {Array<never>} */\nconst empty = []\n\n/**\n * Turn a query into a uniform object.\n *\n * @param {Selectors | RuleSet | null} query\n * @returns {Selectors}\n */\nexport function queryToSelectors(query) {\n  if (query === null) {\n    return {type: 'selectors', selectors: []}\n  }\n\n  if (query.type === 'ruleSet') {\n    return {type: 'selectors', selectors: [query]}\n  }\n\n  return query\n}\n\n/**\n * Walk a tree.\n *\n * @param {SelectState} state\n * @param {Node | undefined} tree\n */\nexport function walk(state, tree) {\n  if (tree) {\n    one(state, [], tree, undefined, undefined)\n  }\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Array<RuleSet>} currentRules\n * @param {Node} node\n * @param {number | undefined} index\n * @param {Parent | undefined} parent\n * @returns {Nest}\n */\nfunction one(state, currentRules, node, index, parent) {\n  /** @type {Nest} */\n  let nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  }\n  const exit = enterState(state, node)\n\n  if (node.type === 'element') {\n    nestResult = applySelectors(\n      state,\n      // Try the root rules for this element too.\n      combine(currentRules, state.rootQuery.selectors),\n      node,\n      index,\n      parent\n    )\n  }\n\n  // If this is a parent, and we want to delve into them, and we haven’t found\n  // our single result yet.\n  if ('children' in node && !state.shallow && !(state.one && state.found)) {\n    all(state, nestResult, node)\n  }\n\n  exit()\n\n  return nestResult\n}\n\n/**\n * Check a node.\n *\n * @param {SelectState} state\n * @param {Nest} nest\n * @param {Parent} node\n * @returns {void}\n */\nfunction all(state, nest, node) {\n  const fromParent = combine(nest.descendant, nest.directChild)\n  /** @type {Array<RuleSet> | undefined} */\n  let fromSibling\n  let index = -1\n  /**\n   * Total counts.\n   * @type {Counts}\n   */\n  const total = {count: 0, types: new Map()}\n  /**\n   * Counts of previous siblings.\n   * @type {Counts}\n   */\n  const before = {count: 0, types: new Map()}\n\n  while (++index < node.children.length) {\n    count(total, node.children[index])\n  }\n\n  index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name =\n      child.type === 'element' ? child.tagName.toUpperCase() : undefined\n    // Before counting further elements:\n    state.elementIndex = before.count\n    state.typeIndex = name ? before.types.get(name) || 0 : 0\n    // After counting all elements.\n    state.elementCount = total.count\n    state.typeCount = name ? total.types.get(name) : 0\n\n    // Only apply if this is a parent, this should be an element, but we check\n    // for parents so that we delve into custom nodes too.\n    if ('children' in child) {\n      const forSibling = combine(fromParent, fromSibling)\n      const nest = one(state, forSibling, node.children[index], index, node)\n      fromSibling = combine(nest.generalSibling, nest.adjacentSibling)\n    }\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    count(before, node.children[index])\n  }\n}\n\n/**\n * Apply selectors to an element.\n *\n * @param {SelectState} state\n *   Current state.\n * @param {Array<RuleSet>} rules\n *   Rules to apply.\n * @param {Element} node\n *   Element to apply rules to.\n * @param {number | undefined} index\n *   Index of node in parent.\n * @param {Parent | undefined} parent\n *   Parent of node.\n * @returns {Nest}\n *   Further rules.\n */\nfunction applySelectors(state, rules, node, index, parent) {\n  /** @type {Nest} */\n  const nestResult = {\n    directChild: undefined,\n    descendant: undefined,\n    adjacentSibling: undefined,\n    generalSibling: undefined\n  }\n  let selectorIndex = -1\n\n  while (++selectorIndex < rules.length) {\n    const ruleSet = rules[selectorIndex]\n\n    // We found one thing, and one is enough.\n    if (state.one && state.found) {\n      break\n    }\n\n    // When shallow, we don’t allow nested rules.\n    // Idea: we could allow a stack of parents?\n    // Might get quite complex though.\n    if (state.shallow && ruleSet.rule.rule) {\n      throw new Error('Expected selector without nesting')\n    }\n\n    // If this rule matches:\n    if (test(ruleSet.rule, node, index, parent, state)) {\n      const nest = ruleSet.rule.rule\n\n      // Are there more?\n      if (nest) {\n        /** @type {RuleSet} */\n        const rule = {type: 'ruleSet', rule: nest}\n        /** @type {keyof Nest} */\n        const label =\n          nest.nestingOperator === '+'\n            ? 'adjacentSibling'\n            : nest.nestingOperator === '~'\n            ? 'generalSibling'\n            : nest.nestingOperator === '>'\n            ? 'directChild'\n            : 'descendant'\n        add(nestResult, label, rule)\n      } else {\n        // We have a match!\n        state.found = true\n\n        if (!state.results.includes(node)) {\n          state.results.push(node)\n        }\n      }\n    }\n\n    // Descendant.\n    if (ruleSet.rule.nestingOperator === null) {\n      add(nestResult, 'descendant', ruleSet)\n    }\n    // Adjacent.\n    else if (ruleSet.rule.nestingOperator === '~') {\n      add(nestResult, 'generalSibling', ruleSet)\n    }\n    // Drop top-level nesting (`undefined`), direct child (`>`), adjacent sibling (`+`).\n  }\n\n  return nestResult\n}\n\n/**\n * Combine two lists, if needed.\n *\n * This is optimized to create as few lists as possible.\n *\n * @param {Array<RuleSet> | undefined} left\n * @param {Array<RuleSet> | undefined} right\n * @returns {Array<RuleSet>}\n */\nfunction combine(left, right) {\n  return left && right && left.length > 0 && right.length > 0\n    ? [...left, ...right]\n    : left && left.length > 0\n    ? left\n    : right && right.length > 0\n    ? right\n    : empty\n}\n\n/**\n * Add a rule to a nesting map.\n *\n * @param {Nest} nest\n * @param {keyof Nest} field\n * @param {RuleSet} rule\n */\nfunction add(nest, field, rule) {\n  const list = nest[field]\n  if (list) {\n    list.push(rule)\n  } else {\n    nest[field] = [rule]\n  }\n}\n\n/**\n * Count a node.\n *\n * @param {Counts} counts\n *   Counts.\n * @param {Node} node\n *   Node (we’re looking for elements).\n * @returns {void}\n *   Nothing.\n */\nfunction count(counts, node) {\n  if (node.type === 'element') {\n    // Uppercase to prevent prototype polution, injecting `constructor` or so.\n    // Normalize because HTML is insensitive.\n    const name = node.tagName.toUpperCase()\n    const count = (counts.types.get(name) || 0) + 1\n    counts.count++\n    counts.types.set(name, count)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}