{"ast":null,"code":"import _wrapRegExp from \"/Users/toji.inoue/Desktop/web3-sotuken/node_modules/@babel/runtime/helpers/esm/wrapRegExp.js\";\nimport { execTyped, isTupleRegex } from '../../regex.js';\nimport { UnknownTypeError } from '../errors/abiItem.js';\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, InvalidStructSignatureError } from '../errors/signature.js';\nimport { CircularReferenceError } from '../errors/struct.js';\nimport { execStructSignature, isStructSignature } from './signatures.js';\nimport { isSolidityType, parseAbiParameter } from './utils.js';\nexport function parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature)) continue;\n    const match = execStructSignature(signature);\n    if (!match) throw new InvalidSignatureError({\n      signature,\n      type: 'struct'\n    });\n    const properties = match.properties.split(';');\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct'\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length) throw new InvalidStructSignatureError({\n      signature\n    });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i];\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /*#__PURE__*/_wrapRegExp(/^([a-zA-Z$_][a-zA-Z0-9$_]*)((?:\\[\\d*?\\])+?)?$/, {\n  type: 1,\n  array: 2\n});\nfunction resolveStructs(abiParameters, structs) {\n  let ancestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n      if (!(match !== null && match !== void 0 && match.type)) throw new InvalidAbiTypeParameterError({\n        abiParameter\n      });\n      const {\n        array,\n        type\n      } = match;\n      if (type in structs) {\n        var _structs$type;\n        if (ancestors.has(type)) throw new CircularReferenceError({\n          type\n        });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array !== null && array !== void 0 ? array : ''}`,\n          components: resolveStructs((_structs$type = structs[type]) !== null && _structs$type !== void 0 ? _structs$type : [], structs, new Set([...ancestors, type]))\n        });\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter);else throw new UnknownTypeError({\n          type\n        });\n      }\n    }\n  }\n  return components;\n}","map":{"version":3,"names":["execTyped","isTupleRegex","UnknownTypeError","InvalidAbiTypeParameterError","InvalidSignatureError","InvalidStructSignatureError","CircularReferenceError","execStructSignature","isStructSignature","isSolidityType","parseAbiParameter","parseStructs","signatures","shallowStructs","signaturesLength","length","i","signature","match","type","properties","split","components","propertiesLength","k","property","trimmed","trim","abiParameter","push","name","resolvedStructs","entries","Object","entriesLength","parameters","resolveStructs","typeWithoutTupleRegex","_wrapRegExp","array","abiParameters","structs","ancestors","arguments","undefined","Set","isTuple","test","_structs$type","has"],"sources":["/Users/toji.inoue/Desktop/web3-sotuken/node_modules/viem/node_modules/abitype/src/human-readable/runtime/structs.ts"],"sourcesContent":["import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\n  structs: StructLookup,\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}